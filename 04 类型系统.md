# 类型系统

## 定义类型

若我们想定义一个类型来表达(平面上的)"圆形"的概念:

第一步,为我们的类型起一个名字,这里就叫这个类型为"圆形".

第二步,说明这个类型是如何构成的.

其实表达圆形的方法有很多种,例如:

- 圆的标准式:(x-a)²+(y-b)²=r².
- 圆的一般式:x²+y²+Dx+Ey+F=0.

在标准式中,我们需要确定的a,b和r.他们代表圆的圆心和半径.

在一般式中,我们需要确定的是D,E,F三个参数.

不管用何种方式构成,最后我们得到的数据都能`表示`圆形.

而能够`表示`原型的`数据`,我们就称,它的类型的`圆形`.

在这里,我们这样写:

```haskell
data Circle = Normal_Circle Number Number Number | General_Circle Number Number Number
```

这表示,定义一个类型,这个类型的名称叫圆形(`Circle`),它有两个构造子.

第一个构造子`Normal_Circle`接收三个参数,这三个参数都是数字类型.

第二个构造子`General_Circle`也接收三个参数,这三个参数也都是数字类型.

请注意, 类型和类型构造子都必须是大写字母开头.

现在我们使用它:

在这里,函数的调用不是用括号,而是用空格,所以写成这样:

```haskell
Normal_Circle 1.0 2.2 3.3
```

在交互模式试试:

```bash
> a = Normal_Circle 1.0 2.2 3.3
> b = General_Circle 1.2 2.5 3.2
> :t a
Circle
> :t b
Circle
```

这说明`Normal_Circle 1.0 2.2 3.3`或`General_Circle 1.2 2.5 3.2`已经是一个数据了,这个数据的类型是`Circle`.

我们也可以将简单类型纳入这个体系.

例如,我现在想定义`布尔`类型:

```haskell
data My_Boolean = True | False
```

没什么可惊讶的,`True`和`False`都是构造子, 只是他们没有参数罢了.

然后我们就可以在交互模式看看:

```bash
> :t True 
My_Boolean

> :t False
My_Boolean

> a = True
> :t a    
My_Boolean
```

没错,数据就是没有参数的函数.

如果我想定义"数字"类型呢?

```haskell
data My_Number = 0 | 1 | 2 | ... | 99999 | ...
```

当然不能这么写, 有更聪明的办法, 但差不多就是这个意思.

## 递归类型

现在我们想定义链表类型.

定义:

```haskell
data List = Nil | Cons Int List
```

这定义了一个链表类型,它有两个构造子:

`Nil`是一个构造子,它没有参数.

`Cons`是另一个构造子,它接受两个参数,第一个参数的类型是`Int`,第二个参数的类型是`List`.(这里用到了递归引用).

注意, `Cons`构造子要求传入一个`List`类型的值, 你当然可以传入`Cons`构造的值, 但第一个`List`是从哪来的呢?就是无参数的`Nil`构造的.

于是我们可以:

```bash
> a = Nil
> b = Cons 1 a
> c = Cons 2 b

> :t a
List
> :t b
List
> :t c 
List
```

a,b,c都是`数据`,它们的`类型`都是`List`.

## 泛型类型

注意到上面的例子,`Cons`构造子接受两个参数,第一个参数是数字,第二个参数是链表.

但如果我想做字符串链表呢?

当然我可以定义:

```haskell
data List_Str = Nil_Str | Cons_Str String List_Str
```

那如果我想定义布尔的链表呢?

```haskell
data List_Bool = Nil_Bool | Cons_Bool Bool List_Bool
```

显得过于麻烦了,于是我们引入了泛型:

```haskell
data List a = Nil | Cons a (List a)
```

这样,我们就定义了一个(泛型)类型,类型的名字是`List a`.

其中,`a`是泛型变量.(为什么是`a`?没什么特别的原因,其他字母也可以,只是传统上大家都写`a`,`b`,`c`...)

虽然`List a`中间有个空格,但他们是连在一起看的,表示一个`类型`.

在交互模式试一下:

```bash
> :t (Cons 1 Nil)
List Int

> :t (Cons "a" Nil)
List String

> :t (Cons [1,2,3] Nil)
List (Array Int)

> :t Nil
forall (t1 :: Type). List t1
```

先看`Cons 1 Nil`,和我们的定义比较一下:

```haskell
Cons a (List a)  -- 定义
Cons 1 Nil       -- 使用  
```

可以看到定义上`a`的位置填入了`1`, 而`1`的类型是`Int`.

所以系统会知道, `a`现在表示的是`Int`, 于是`List a`类型就变成了`List Int`类型.

唯一特别的是`Nil`的类型, 它的类型是`List a`类型.

因为`a`是可以随便写的, 系统就把他换成了`t1`, 就变成了`forall (t1 :: Type). List t1`.

至于这个`forall (t1 :: Type)`,只是说明, `t1`是一个`kind类型`为`Type`的类型. 之后还会讨论关于这方面的问题.

这是什么意思? 这说明`Nil`可以是任意的`List`泛型的值, 它可以是`List Int`, 也可以是`List String`, 也可以是其他的.

所以你看到, 我们既可以`(Cons 1 Nil)`, 又可以`(Cons "a" Nil)`.

在`(Cons 1 Nil)`的时候, `Nil`是`List Int`类型, 在`(Cons "a" Nil)`的时候, `Nil`是`List String`类型. 而单独的`Nil`, 就是`List a`类型.

## kind类型

我们不能查看`List`的类型,因为`List`本来就是类型.

所以`:t List`会报错,这也是理所当然的.

但类型也是有类型的,称为`kind类型`.

```bash
# 使用`:k <类型>`来查看类型的kind类型
# 简单类型的kind类型都是`Type`
> :k Int
Type

> :k String
Type

# List是一个泛型 它的kind类型是`Type -> Type`
> :k List
Type -> Type

# 同样是泛型的还有Array
> :k Array 
Type -> Type

# 泛型类型被实例后 它的kind类型是`Type`
> :k (List Int)
Type
```

那么`List`是什么?是一个"高级的类型",通过构造时传参的不同,它可以变成`List Int`,`List String`等等类型.

而`List Int`,`List String`等等类型的`kind类型`就是`Type`了.

你可以把它理解为类型级别上的函数调用:

`List`是一个函数, 它接受一个参数, 形式参数写作`a`. 这个函数的签名是`Type -> Type`, 也就是, 输入一个`Type`类型的东西, 返回一个`Type`类型的东西.

恰好, 我们有一个叫`Int`的东西, 它就是`Type`类型的, 用它来调用`List`之后, 得到了`List Int`, 同时`List Int`的签名也变成了`Type`.

而你不能把`Array`传入`List`, 因为`Array`的类型是`(Type -> Type)`, 而`List`接受的是`Type`类型的东西.

```haskell
> :k (List Array)
Error found:
  Could not match kind
    Type -> Type
  with kind
    Type
```

提示写的很清楚, 需求`Type`类型的东西, 而你输入了`(Type->Type)`类型的东西.

但你可以输入`(Array Int)`, 因为它已经是`Type`类型的东西了.

```haskell
> :k (List (Array Int))
Type
```
