# 读一些源码

我们来看看一些常见函数的实现, 更重要的是演示如何通过阅读源码学习.

## head

这个函数接受一个`List`, 如果`List`非空, 返回`Just`包裹的第一个元素, 否则返回`Nothing`.

```haskell
fun :: List Int -> Maybe Int
fun a = head a
```

测试:

```bash
> fun (1:2:3:Nil) 
(Just 1)
> fun Nil        
Nothing
```

按住`Ctrl`点`head`函数, 可以看到它的实现.

```haskell
head :: List ~> Maybe
head Nil = Nothing
head (x : _) = Just x
```

出现了一个奇怪的`~>`,`ctrl`点进去可以看到:

```haskell
type NaturalTransformation :: forall k. (k -> Type) -> (k -> Type) -> Type
type NaturalTransformation f g = forall a. f a -> g a

infixr 4 type NaturalTransformation as ~>
```

它是类型别名`NaturalTransformation`的中缀表达形式, 翻译一下就是`f ~> g`等价于`f a -> g a`.

那么我们的`List ~> Maybe`就是`List a -> Maybe a`.

也就是接受任意泛型的`List`类型, 返回同样类型是`Maybe`类型, 比如, 如果输入`List Int`类型, 就会返回`Maybe Int`类型.

实现也很简单, 如果输入的`List`是`Nil`, 就返回`Nothing`, 不然就取出`List`的第一个元素, 把他丢到`Just`里.

这里说到的`Nothing`和`Just`是`Maybe`类型的构造子, 也可以点进去看看:

```haskell
data Maybe a = Nothing | Just a
```

## filter

这个函数接收一个函数和一个`List`, 就像它的名字所说, 过滤掉`List`的一部分元素.

```haskell
fun :: List Int -> List Int
fun arr = filter (\a -> a > 2) arr
```

测试:

```bash
> filter (\a -> a < 2) (1:2:3:Nil)
(1 : Nil)
```

点进去看看:

```haskell
filter :: forall a. (a -> Boolean) -> List a -> List a
filter p = go Nil
  where
  go acc Nil = reverse acc
  go acc (x : xs)
    | p x = go (x : acc) xs
    | otherwise = go acc xs
```

有一个`reverse`函数, 是反转一个`List`, 我们等下再看它的实现, 先看这个`filter`.

先看参数, 接受两个参数, 第一个是一个接受任意类型, 返回布尔值的函数, 第二个是一个任意泛型的`List`,然后会返回同类型的`List`.

它用了`point-free`写法, 完整的写法是`filter p a = go Nil a`,其中`p`是传入的函数, `a`是输入的`List`.

接下来调用`go`函数, 我们输入的`List`是被作为第二个参数传入的.

然后`go`函数的定义在`where`里:

接收两个参数, 如果第二个参数为空, 就反转第一个参数.

否则, 先用模式匹配把第二个参数的第一项取出来, 传给函数`p`.

如果`p`返回真, 就把这项拼接到第一个参数里, 然后把它作为第一参数, 把剩余项作为第二参数, 递归调用`go`函数.

如果`p`返回假, 就抛弃这项, 用剩余项递归调用`go`函数.

## reverse

再看`reverse`, 刚才说过, 它是反转`List`的函数:

```haskell
reverse :: List ~> List
reverse = go Nil
  where
  go acc Nil = acc
  go acc (x : xs) = go (x : acc) xs
```

`List ~> List`已经说过, 它等价于`List a -> List a`, 即, 输入一个任意泛型的`List`, 返回同类型的`List`. 比如输入`List Int`, 就会返回`List Int`.

下面这里用了`point-free`模式, 完整的写法是`reverse a = go Nil a`, 其中`a`就是输入的`List`.

然后`go`是一个函数, 在下面的`where`部分定义了:

如果输入的第二个参数(也就是我们输入的List)是Nil的话, 直接返回第一个参数.

否则, 把第一项取出来, 拼接到第一个参数上, 把这个作为第一个参数, 把剩余的项作为第二个参数, 递归调用`go`函数.

可以看到,这样会把`List`反转.

## todo

更多的回头再写