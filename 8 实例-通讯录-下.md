# å®ä¾‹-é€šè®¯å½•-ä¸‹

## åˆ›å»ºç©ºé€šè®¯å½•

æˆ‘ä»¬å…ˆåˆ›å»ºä¸€ä¸ªæ•°æ®, ä½œä¸ºç©ºçš„é€šè®¯å½•, å¹¶ä¸”è¯´æ˜å®ƒçš„ç±»å‹æ˜¯`AddressBook`:

```haskell
emptyBook :: AddressBook
emptyBook = Nil
```

ç°åœ¨`Nil`è¿˜ä¸èƒ½ä½¿ç”¨,éœ€è¦åœ¨å¼•å…¥çš„æ—¶å€™,è¯´æ˜è¦å¼•å…¥`List`çš„`Nil`æ„é€ å­.

```haskell
import Data.List (List(Nil))
```

å¦‚æœè¿˜æƒ³å¼•å…¥`Cons`æ„é€ å­, å¯ä»¥

```haskell
import Data.List (List(Nil, Cons))
```

å¦‚æœè¦å¼•å…¥å…¨éƒ¨æ„é€ å­, å¯ä»¥

```haskell
import Data.List (List(..))
```

ç°åœ¨ä½ çš„æ–‡ä»¶å¤§æ¦‚é•¿è¿™æ ·:

```haskell
module Main where

import Prelude
import Effect (Effect)
import Effect.Console (log)
import Data.List (List(..))

type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }

type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }

type AddressBook = List Entry

showEntry :: Entry -> String
showEntry entry = entry.lastName <> ", " <> entry.firstName <> ": " <> showAddress entry.address

showAddress :: Address -> String
showAddress addr = addr.street <> ", " <> addr.city <> ", " <> addr.state

emptyBook :: AddressBook
emptyBook = Nil

main :: Effect Unit
main = do
  log "ğŸ"
```

## æ’å…¥

ç°åœ¨æˆ‘ä»¬å†™ä¸€ä¸ªå‡½æ•°, å®ƒæ¥å—ä¸€ä¸ªé€šè®¯å½•æ¡ç›®(`Entry`)å’Œä¸€ä¸ªé€šè®¯å½•(`AddressBook`), è¿”å›å¦ä¸€ä¸ªé€šè®¯å½•(`AddressBook`).

```haskell
insertEntry :: Entry -> AddressBook -> AddressBook
insertEntry entry book = Cons entry book
```

å½“ç„¶ä½ ä¹Ÿå¯ä»¥æŠŠä»–å†™æˆ`point-free`å½¢å¼,å¯ä»¥åˆ†åˆ«æŠŠ`book`å’Œ`entry`éƒ½çº¦æ‰:

```haskell
insertEntry :: Entry -> AddressBook -> AddressBook
insertEntry = Cons
```

é™¤æ­¤ä»¥å¤–, æˆ‘ä»¬è¿˜éœ€è¦æœ‰ä¸€ä¸ªæŠŠé€šè®¯å½•è½¬æ¢æˆå­—ç¬¦ä¸²çš„å‡½æ•°, åªæœ‰å­—ç¬¦ä¸²æ‰èƒ½è¢«æ‰“å°å‡ºæ¥.

```haskell
showAddressBook :: AddressBook -> String
showAddressBook Nil = ""
showAddressBook (Cons entry book) = showEntry entry <> ";" <> showAddressBook book
```

ç°åœ¨ä½ çš„æ–‡ä»¶å¤§æ¦‚æ˜¯è¿™æ ·:

```haskell
module Main where

import Prelude
import Effect (Effect)
import Effect.Console (log)
import Data.List (List(..))

type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }

type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }

type AddressBook = List Entry

showEntry :: Entry -> String
showEntry entry = entry.lastName <> ", " <> entry.firstName <> ": " <> showAddress entry.address

showAddress :: Address -> String
showAddress addr = addr.street <> ", " <> addr.city <> ", " <> addr.state

emptyBook :: AddressBook
emptyBook = Nil

insertEntry :: Entry -> AddressBook -> AddressBook
insertEntry = Cons

showAddressBook :: AddressBook -> String
showAddressBook Nil = ""
showAddressBook (Cons entry book) = showEntry entry <> ";" <> showAddressBook book

main :: Effect Unit
main = do
  log "ğŸ"
```

è¯•è¯•:

```bash
> address = { street: "123 Fake St.", city: "Faketown", state: "CA" }
> entry = { firstName: "John", lastName: "Smith", address: address }
> showAddressBook (insertEntry entry emptyBook)                      
"Smith, John: 123 Fake St., Faketown, CA;"
```

## è®°å½•è®¿é—®å™¨

å¦‚æœæˆ‘ä»¬è¦å†™ä¸€ä¸ªå‡½æ•°, è¿”å›ç»™å®šçš„è®°å½•çš„æŸä¸€é¡¹, å¤§æ¦‚æ˜¯è¿™æ ·:

```haskell
getFirstName :: Entry -> String
getFirstName entry = entry.firstName
```

æœ‰ä¸ªç®€å•çš„è¯­æ³•ç³–å¯ä»¥é¿å…æˆ‘ä»¬ç¼–å†™è¿™æ ·çš„å‡½æ•°:

```bash
> address = { street: "123 Fake St.", city: "Faketown", state: "CA" }
> entry = { firstName: "John", lastName: "Smith", address: address }
> _.lastName entry
"Smith"
> _.address.city entry
"Faketown"
```

## æŸ¥è¯¢

æˆ‘ä»¬å†™ä¸€ä¸ªå‡½æ•°,è¾“å…¥å§“å,æŸ¥å‡ºåœ°å€:

```haskell
findEntry :: String -> String -> AddressBook -> Maybe Entry
findEntry firstName lastName book = head (filter filterEntry book)
  where
    filterEntry :: Entry -> Boolean
    filterEntry entry = entry.firstName == firstName && entry.lastName == lastName
```

æˆ‘ä»¬çœ‹åˆ°äº†å‡ ä¸ªæ–°ä¸œè¥¿, é¦–å…ˆæ˜¯`head`å’Œ`filter`.è¿™æ˜¯ä¸¤ä¸ª`List`çš„å¤„ç†å‡½æ•°,ä¹Ÿå®šä¹‰åœ¨`Data.List`æ¨¡å—.

è¦å¼•å…¥å®ƒçš„è¯, ä½ åº”è¯¥æŠŠå¼•å…¥çš„éƒ¨åˆ†æ”¹æˆ:

```haskell
import Data.List (List(..), head, filter)
```

`head`æ˜¯å–`List`çš„ç¬¬ä¸€ä¸ªå…ƒç´ , `filter`æ¥å—ä¸¤ä¸ªå‚æ•°, ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªå‡½æ•°, ç¬¬äºŒä¸ªå‚æ•°æ˜¯ä¸€ä¸ª`List`. å°±åƒä»–çš„åå­—æ‰€è¯´, ç”¨å‡½æ•°è¿‡æ»¤`List`.

æŒ‰ä½`ctrl`, ç‚¹å‡»å‡½æ•°, å°±å¯ä»¥çœ‹åˆ°å®ƒçš„ç­¾åå’Œå®ç°.

æ¥ä¸‹æ¥æ˜¯`Maybe`, è¿™æ˜¯ä¸€ä¸ªç±»å‹, å°±åƒ`List`ä¸€æ ·, å®ƒä¹Ÿæ˜¯ä¸€ä¸ªæ³›å‹ç±»å‹. æŒ‰ä½`ctrl`, ç‚¹å‡»å®ƒ, ä¹Ÿå¯ä»¥çœ‹åˆ°å®ƒçš„æºç .

ä¸åªæ˜¯ç±»å‹å’Œå‡½æ•°, ä»»ä½•ç¬¦å·å‡ ä¹éƒ½å¯¹åº”ç€æºç çš„å®ç°, çœ‹æºç æ˜¯ä¸»è¦çš„å­¦ä¹ æ–¹æ³•, é€šå¸¸è¿™äº›æºç éƒ½éå¸¸ç®€çŸ­, è¿˜å¸¦æœ‰æ³¨é‡Š, ä¸éš¾çœ‹æ‡‚.

æœºä¼šéš¾å¾—, æ¼”ç¤ºä¸€ä¸‹å¦‚ä½•è¯»ä»£ç å§.

### head

é‚£ä¹ˆå…ˆçœ‹ä¸€ä¸‹`head`çš„å®ç°:

```haskell
head :: List ~> Maybe
head Nil = Nothing
head (x : _) = Just x
```

å‡ºç°äº†ä¸€ä¸ªå¥‡æ€ªçš„`~>`,`ctrl`ç‚¹è¿›å»å¯ä»¥çœ‹åˆ°:

```haskell
type NaturalTransformation :: forall k. (k -> Type) -> (k -> Type) -> Type
type NaturalTransformation f g = forall a. f a -> g a

infixr 4 type NaturalTransformation as ~>
```

å®ƒæ˜¯ç±»å‹åˆ«å`NaturalTransformation`çš„ä¸­ç¼€è¡¨è¾¾å½¢å¼, ç¿»è¯‘ä¸€ä¸‹å°±æ˜¯`f ~> g`ç­‰ä»·äº`f a -> g a`.

é‚£ä¹ˆæˆ‘ä»¬çš„`List ~> Maybe`å°±æ˜¯`List a -> Maybe a`.

ä¹Ÿå°±æ˜¯æ¥å—ä»»æ„æ³›å‹çš„`List`ç±»å‹, è¿”å›åŒæ ·ç±»å‹æ˜¯`Maybe`ç±»å‹, æ¯”å¦‚, å¦‚æœè¾“å…¥`List Int`ç±»å‹, å°±ä¼šè¿”å›`Maybe Int`ç±»å‹.

å®ç°ä¹Ÿå¾ˆç®€å•, å¦‚æœè¾“å…¥çš„`List`æ˜¯`Nil`, å°±è¿”å›`Nothing`, ä¸ç„¶å°±å–å‡º`List`çš„ç¬¬ä¸€ä¸ªå…ƒç´ , æŠŠä»–ä¸¢åˆ°`Just`é‡Œ.

`Nothing`å’Œ`Just`æ˜¯`Maybe`ç±»å‹çš„æ„é€ å­:

```haskell
data Maybe a = Nothing | Just a
```

### filter

å†çœ‹çœ‹`filter`å‡½æ•°:

```haskell
filter :: forall a. (a -> Boolean) -> List a -> List a
filter p = go Nil
  where
  go acc Nil = reverse acc
  go acc (x : xs)
    | p x = go (x : acc) xs
    | otherwise = go acc xs
```

æœ‰ä¸€ä¸ª`reverse`å‡½æ•°å’Œä¸€ä¸ªç«–çº¿çš„å¥‡æ€ªå†™æ³•.

#### å«å…µæ¨¡å¼

å…ˆè§£é‡Šä¸€ä¸‹`å«å…µæ¨¡å¼`(Guards).

ç®€å•çš„è¯´,å°±æ˜¯æ¡ä»¶åˆ¤æ–­:

```haskell
  go acc (x : xs)
    | p x = go (x : acc) xs
    | otherwise = go acc xs
```

`go`æ˜¯å‡½æ•°å, `acc`æ˜¯ç¬¬ä¸€ä¸ªå‚æ•°, `(x : xs)`æ˜¯æ¨¡å¼åŒ¹é…, å…¶ä¸­çš„`:`æ˜¯`Cons`çš„ä¸­ç¼€ç¬¦å·, `ctrl`ç‚¹è¿›å»å¯ä»¥çœ‹åˆ°:

```haskell
data List a = Nil | Cons a (List a)

infixr 6 Cons as :
```

ä¸‹é¢çš„`| p x = go (x : acc) xs`è¡¨ç¤º, å¦‚æœ`p x`ä¸ºçœŸ, åˆ™è¿”å›`go (x : acc) xs`.å¦åˆ™, å‘ä¸‹ç»§ç»­æ‰§è¡Œ.

ä¸‹é¢çš„`| otherwise = go acc xs`è¡¨ç¤º, å¦‚æœæ‰§è¡Œåˆ°è¿™äº†, å°±è¿”å›`go acc xs`.

å«å…µæ¨¡å¼ç±»ä¼¼äº`if-elif-else`æ¨¡å¼.

#### reverse

ç‚¹è¿›`reverse`å¯ä»¥çœ‹åˆ°:

```haskell
reverse :: List ~> List
reverse = go Nil
  where
  go acc Nil = acc
  go acc (x : xs) = go (x : acc) xs
```

`List ~> List`å·²ç»è¯´è¿‡, å®ƒç­‰ä»·äº`List a -> List a`, å³, è¾“å…¥ä¸€ä¸ªä»»æ„æ³›å‹çš„`List`, è¿”å›åŒç±»å‹çš„`List`. æ¯”å¦‚è¾“å…¥`List Int`, å°±ä¼šè¿”å›`List Int`.

ä¸‹é¢è¿™é‡Œç”¨äº†`point-free`æ¨¡å¼, å®Œæ•´çš„å†™æ³•æ˜¯`reverse a = go Nil a`, å…¶ä¸­`a`å°±æ˜¯è¾“å…¥çš„`List`.

ç„¶å`go`æ˜¯ä¸€ä¸ªå‡½æ•°, åœ¨ä¸‹é¢çš„`where`éƒ¨åˆ†å®šä¹‰äº†:

å¦‚æœè¾“å…¥çš„ç¬¬äºŒä¸ªå‚æ•°(ä¹Ÿå°±æ˜¯æˆ‘ä»¬è¾“å…¥çš„List)æ˜¯Nilçš„è¯, ç›´æ¥è¿”å›ç¬¬ä¸€ä¸ªå‚æ•°.

å¦åˆ™, æŠŠç¬¬ä¸€é¡¹å–å‡ºæ¥, æ‹¼æ¥åˆ°ç¬¬ä¸€ä¸ªå‚æ•°ä¸Š, æŠŠè¿™ä¸ªä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°, æŠŠå‰©ä½™çš„é¡¹ä½œä¸ºç¬¬äºŒä¸ªå‚æ•°, é€’å½’è°ƒç”¨`go`å‡½æ•°.

å¯ä»¥çœ‹åˆ°,è¿™æ ·ä¼šæŠŠ`List`åè½¬.

#### ç»“è®º

å†çœ‹å¼€å§‹çš„è¿™ä¸ª`filter`:

```haskell
filter :: forall a. (a -> Boolean) -> List a -> List a
filter p = go Nil
  where
  go acc Nil = reverse acc
  go acc (x : xs)
    | p x = go (x : acc) xs
    | otherwise = go acc xs
```

å…ˆçœ‹å‚æ•°, æ¥å—ä¸¤ä¸ªå‚æ•°, ç¬¬ä¸€ä¸ªæ˜¯ä¸€ä¸ªæ¥å—ä»»æ„ç±»å‹, è¿”å›å¸ƒå°”å€¼çš„å‡½æ•°, ç¬¬äºŒä¸ªæ˜¯ä¸€ä¸ªä»»æ„æ³›å‹çš„`List`,ç„¶åä¼šè¿”å›åŒç±»å‹çš„`List`.

å®ƒä¹Ÿç”¨äº†`point-free`å†™æ³•, å®Œæ•´çš„å†™æ³•æ˜¯`filter p a = go Nil a`,å…¶ä¸­`p`æ˜¯ä¼ å…¥çš„å‡½æ•°, `a`æ˜¯è¾“å…¥çš„`List`.

æ¥ä¸‹æ¥è°ƒç”¨`go`å‡½æ•°, æˆ‘ä»¬è¾“å…¥çš„`List`æ˜¯è¢«ä½œä¸ºç¬¬äºŒä¸ªå‚æ•°ä¼ å…¥çš„.

ç„¶å`go`å‡½æ•°çš„å®šä¹‰åœ¨`where`é‡Œ:

æ¥æ”¶ä¸¤ä¸ªå‚æ•°, å¦‚æœç¬¬äºŒä¸ªå‚æ•°ä¸ºç©º, å°±åè½¬ç¬¬ä¸€ä¸ªå‚æ•°.

å¦åˆ™, å…ˆç”¨æ¨¡å¼åŒ¹é…æŠŠç¬¬äºŒä¸ªå‚æ•°çš„ç¬¬ä¸€é¡¹å–å‡ºæ¥, ä¼ ç»™å‡½æ•°`p`.

å¦‚æœ`p`è¿”å›çœŸ, å°±æŠŠè¿™é¡¹æ‹¼æ¥åˆ°ç¬¬ä¸€ä¸ªå‚æ•°é‡Œ, ç„¶åæŠŠå®ƒä½œä¸ºç¬¬ä¸€å‚æ•°, æŠŠå‰©ä½™é¡¹ä½œä¸ºç¬¬äºŒå‚æ•°, é€’å½’è°ƒç”¨`go`å‡½æ•°.

å¦‚æœ`p`è¿”å›å‡, å°±æŠ›å¼ƒè¿™é¡¹, ç”¨å‰©ä½™é¡¹é€’å½’è°ƒç”¨`go`å‡½æ•°.

### ç»“è®º

éƒ½è§£é‡Šæ¸…æ¥šäº†, å†æ¥çœ‹ä¸€å¼€å§‹è¿™ä¸ªå‡½æ•°.

```haskell
findEntry :: String -> String -> AddressBook -> Maybe Entry
findEntry firstName lastName book = head (filter filterEntry book)
  where
    filterEntry :: Entry -> Boolean
    filterEntry entry = entry.firstName == firstName && entry.lastName == lastName
```

è¾“å…¥å§“å,é€šè®¯å½•,è¿”å›ä¸€ä¸ª`Maybe Entry`, å°±æ˜¯è¢«`Maybe`åŒ…è£¹çš„é€šè®¯å½•é¡¹.

å®ç°å¾ˆç®€å•, æŒ‰`filterEntry`å°†è¾“å…¥çš„é€šè®¯å½•è¿‡æ»¤, å¹¶å–å®ƒçš„ç¬¬ä¸€ä¸ªé¡¹.

è€Œ`filterEntry`å®šä¹‰åœ¨`where`é‡Œ:è¾“å…¥ä¸€ä¸ªé€šè®¯å½•é¡¹, åˆ¤æ–­å§“åæ˜¯å¦ç¬¦åˆæˆ‘ä»¬ä¼ å…¥çš„å§“å, ç¬¦åˆè¿”å›çœŸ, ä¸ç¬¦åˆè¿”å›å‡.

è¿™æ ·è‡ªç„¶å°±æ‰¾åˆ°äº†åŒ¹é…å§“åçš„é‚£ä¸ªæ¡ç›®.

### å‡½æ•°ç»„åˆ

å¦å¤–

å¯ä»¥ç”¨å¦ä¸€ç§å†™æ³•:

```haskell
findEntry firstName lastName book = (head <<< filter filterEntry) book
```

è¿™ä¸ª`<<<`ç¬¦å·æ˜¯å‡½æ•°ç»„åˆ, å¯¹äºä¸¤ä¸ªå•å‚æ•°å‡½æ•°, æ˜¯å¯ä»¥ç»„åˆçš„.

ä¾‹å¦‚, `f(x) = a(b(x))`çš„æ„æ€æ˜¯, å‡½æ•°fæœ‰ä¸€ä¸ªå‚æ•°, è¿™ä¸ªå‚æ•°ä¼šè¢«bè®¡ç®—, å¾—åˆ°çš„ç»“æœå†è¢«aè®¡ç®—.

è¿™æ ·æˆ‘ä»¬å°±æŠŠå‡½æ•°`a`,`b`ç»„åˆæˆäº†å‡½æ•°`f`.å¦‚æœå†™ä½œç®­å¤´å°±æ˜¯`(a <<< b)`.

è™½ç„¶`filter`å¹¶ä¸æ˜¯å•å‚å‡½æ•°, ä½†å› ä¸ºæŸ¯é‡ŒåŒ–, è¾“å…¥äº†`filterEntry`å, `filter filterEntry`å·²ç»æ˜¯å•å‚å‡½æ•°äº†.

è¿™æ ·å¤„ç†å, è¿˜å¯ä»¥å†ä½¿ç”¨ä¸€æ¬¡`point-free`å½¢å¼:

```haskell
findEntry firstName lastName = (head <<< filter filterEntry)
```

å¦å¤–, ä½ ä¹Ÿå¯ä»¥å†™:

```haskell
findEntry firstName lastName = (filter filterEntry >>> head)
```

ä¸åŒçš„ç»„åˆæ–¹å‘è€Œå·².

## æµ‹è¯•

ç°åœ¨, æˆ‘ä»¬å¯ä»¥é€šè¿‡`findEntry`æŸ¥æ‰¾é€šè®¯å½•çš„äººäº†, ä½†å®ƒè¿”å›çš„æ˜¯ä¸€ä¸ª`Maybe Entry`.

æˆ‘ä»¬è¦æµ‹è¯•çš„è¯, åªèƒ½æ‰“å°å‡ºå­—ç¬¦ä¸², æ‰€ä»¥æˆ‘ä»¬å¾—å†™ä¸€ä¸ª`Maybe Entry`è½¬å­—ç¬¦ä¸²çš„å‡½æ•°.

```haskell
showMaybeEntry :: Maybe Entry -> String
showMaybeEntry Nothing = "Nothing"
showMaybeEntry (Just a) = "Just (" <> showEntry a <> ")"
```

ç°åœ¨ä½ çš„æ–‡ä»¶å¤§æ¦‚æ˜¯è¿™æ ·:

```haskell
module Main where

import Prelude

import Data.List (List(..), head, filter)
import Data.Maybe (Maybe(..))
import Effect (Effect)
import Effect.Console (log)

type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }

type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }

type AddressBook = List Entry

showEntry :: Entry -> String
showEntry entry = entry.lastName <> ", " <> entry.firstName <> ": " <> showAddress entry.address

showAddress :: Address -> String
showAddress addr = addr.street <> ", " <> addr.city <> ", " <> addr.state

emptyBook :: AddressBook
emptyBook = Nil

insertEntry :: Entry -> AddressBook -> AddressBook
insertEntry = Cons

showAddressBook :: AddressBook -> String
showAddressBook Nil = ""
showAddressBook (Cons entry book) = showEntry entry <> ";" <> showAddressBook book

findEntry :: String -> String -> AddressBook -> Maybe Entry
findEntry firstName lastName book = head (filter filterEntry book)
  where
    filterEntry :: Entry -> Boolean
    filterEntry entry = entry.firstName == firstName && entry.lastName == lastName

showMaybeEntry :: Maybe Entry -> String
showMaybeEntry Nothing = "Nothing"
showMaybeEntry (Just a) = "Just (" <> showEntry a <> ")"

main :: Effect Unit
main = do
  log "ğŸ"
```

å¥½äº†, æ¥æµ‹è¯•:

```bash
> address = { street: "123 Fake St.", city: "Faketown", state: "CA" }
> entry = { firstName: "John", lastName: "Smith", address: address }
> newBook = insertEntry entry emptyBook
> findData = findEntry "John" "Smith" newBook 
> showMaybeEntry findData    
"Just (Smith, John: 123 Fake St., Faketown, CA)"
> showMaybeEntry ( findEntry "aaa" "bbb" newBook )              
"Nothing"
```

## è¿è¡Œ

å¦‚æœä¸æƒ³æŠ˜è…¾äº¤äº’æ¨¡å¼äº†, å¯ä»¥å†™åˆ°æºç é‡Œ, ç›´æ¥è¿è¡Œ:

```haskell
module Main where

import Prelude

import Data.List (List(..), head, filter)
import Data.Maybe (Maybe(..))
import Effect (Effect)
import Effect.Console (log)

type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }

type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }

type AddressBook = List Entry

showEntry :: Entry -> String
showEntry entry = entry.lastName <> ", " <> entry.firstName <> ": " <> showAddress entry.address

showAddress :: Address -> String
showAddress addr = addr.street <> ", " <> addr.city <> ", " <> addr.state

emptyBook :: AddressBook
emptyBook = Nil

insertEntry :: Entry -> AddressBook -> AddressBook
insertEntry = Cons

showAddressBook :: AddressBook -> String
showAddressBook Nil = ""
showAddressBook (Cons entry book) = showEntry entry <> ";" <> showAddressBook book

findEntry :: String -> String -> AddressBook -> Maybe Entry
findEntry firstName lastName book = head (filter filterEntry book)
  where
    filterEntry :: Entry -> Boolean
    filterEntry entry = entry.firstName == firstName && entry.lastName == lastName

showMaybeEntry :: Maybe Entry -> String
showMaybeEntry Nothing = "Nothing"
showMaybeEntry (Just a) = "Just (" <> showEntry a <> ")"

address :: Address
address = { street: "123 Fake St.", city: "Faketown", state: "CA" }

entryData :: Entry
entryData = { firstName: "John", lastName: "Smith", address: address }

newBook :: AddressBook
newBook = insertEntry entry emptyBook

main :: Effect Unit
main = do
  log (showMaybeEntry (findEntry "John" "Smith" newBook))
```

ç°åœ¨ä½¿ç”¨`spago run`è¿è¡Œ:

```bash
$ spago run
[info] Build succeeded.
Just (Smith, John: 123 Fake St., Faketown, CA)
```

### ç¾å…ƒç¬¦

å› ä¸ºè¿ç®—ä¼˜å…ˆçº§çš„é—®é¢˜, `log`è¿™é‡Œçš„æ‹¬å·æ˜¯å¿…é¡»çš„.

å¦‚æœä¸åŠ æ‹¬å·, ä¾‹å¦‚è¿™æ ·: `log showMaybeEntry findEntry "John" "Smith" newBook`.

å°±ä¼šå˜æˆ, ç”¨`showMaybeEntry`å»è°ƒç”¨`log`, å¾—åˆ°çš„å€¼ä¼šæ˜¯ä¸€ä¸ªå‡½æ•°, å†ç”¨`findEntry`è°ƒç”¨è¿™ä¸ªå‡½æ•°, ç­‰ç­‰...

å¹¸è¿çš„æ˜¯, æœ‰ä¸ªç¬¦å·å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜:

```haskell
apply :: forall a b. (a -> b) -> a -> b
apply f x = f x

infixr 0 apply as $
```

æœ‰ä¸€ä¸ªå‡½æ•°, `apply`, å®ƒæ¥æ”¶ä¸¤ä¸ªå‚æ•°, ç¬¬ä¸€ä¸ªæ˜¯å‡½æ•°, ç¬¬äºŒä¸ªæ˜¯å€¼, å®ƒä»¥å€¼è°ƒç”¨å‡½æ•°. å…¶å®ä»–ä»€ä¹ˆéƒ½æ²¡åš.

ä½†é‡å®šä¹‰ä¸ºæœ€ä½ä¼˜å…ˆçº§å, å°±å‡ºç°äº†ç¥å¥‡çš„æ•ˆæœ.

```haskell
  log $ showMaybeEntry (findEntry "John" "Smith" newBook)
```

å› ä¸º`$`çš„ä¼˜å…ˆçº§æœ€ä½, æ‰€ä»¥å®ƒå·¦è¾¹çš„å½’å·¦è¾¹, å³è¾¹çš„å½’å³è¾¹, åªæœ‰å·¦å³éƒ½å®Œæˆå, æ‰ä¼šç”¨å·¦è°ƒç”¨å³.

è¿™æ•ˆæœ, ç­‰ä»·äºæŠŠå³è¾¹çš„æ‰€æœ‰å†…å®¹åŠ ä¸ªæ‹¬å·.

å¯ä»¥è¿›ä¸€æ­¥ç®€åŒ–:

```haskell
  log $ showMaybeEntry $ findEntry "John" "Smith" newBook
```

æ¼‚äº®å¤šäº†.
