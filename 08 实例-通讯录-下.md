# 实例-通讯录-下

## 创建空通讯录

我们先创建一个数据, 作为空的通讯录, 并且说明它的类型是`AddressBook`:

```haskell
emptyBook :: AddressBook
emptyBook = Nil
```

现在`Nil`还不能使用,需要在引入的时候,说明要引入`List`的`Nil`构造子.

```haskell
import Data.List (List(Nil))
```

如果还想引入`Cons`构造子, 可以

```haskell
import Data.List (List(Nil, Cons))
```

如果要引入全部构造子, 可以

```haskell
import Data.List (List(..))
```

现在你的文件大概长这样:

```haskell
module Main where

import Prelude
import Effect (Effect)
import Effect.Console (log)
import Data.List (List(..))

type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }

type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }

type AddressBook = List Entry

showEntry :: Entry -> String
showEntry entry = entry.lastName <> ", " <> entry.firstName <> ": " <> showAddress entry.address

showAddress :: Address -> String
showAddress addr = addr.street <> ", " <> addr.city <> ", " <> addr.state

emptyBook :: AddressBook
emptyBook = Nil

main :: Effect Unit
main = do
  log "🍝"
```

## 插入

现在我们写一个函数, 它接受一个通讯录条目(`Entry`)和一个通讯录(`AddressBook`), 返回另一个通讯录(`AddressBook`).

```haskell
insertEntry :: Entry -> AddressBook -> AddressBook
insertEntry entry book = Cons entry book
```

当然你也可以把他写成`point-free`形式,可以分别把`book`和`entry`都约掉:

```haskell
insertEntry :: Entry -> AddressBook -> AddressBook
insertEntry = Cons
```

除此以外, 我们还需要有一个把通讯录转换成字符串的函数, 只有字符串才能被打印出来.

```haskell
showAddressBook :: AddressBook -> String
showAddressBook Nil = ""
showAddressBook (Cons entry book) = showEntry entry <> ";" <> showAddressBook book
```

现在你的文件大概是这样:

```haskell
module Main where

import Prelude
import Effect (Effect)
import Effect.Console (log)
import Data.List (List(..))

type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }

type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }

type AddressBook = List Entry

showEntry :: Entry -> String
showEntry entry = entry.lastName <> ", " <> entry.firstName <> ": " <> showAddress entry.address

showAddress :: Address -> String
showAddress addr = addr.street <> ", " <> addr.city <> ", " <> addr.state

emptyBook :: AddressBook
emptyBook = Nil

insertEntry :: Entry -> AddressBook -> AddressBook
insertEntry = Cons

showAddressBook :: AddressBook -> String
showAddressBook Nil = ""
showAddressBook (Cons entry book) = showEntry entry <> ";" <> showAddressBook book

main :: Effect Unit
main = do
  log "🍝"
```

试试:

```bash
> address = { street: "123 Fake St.", city: "Faketown", state: "CA" }
> entry = { firstName: "John", lastName: "Smith", address: address }
> showAddressBook (insertEntry entry emptyBook)                      
"Smith, John: 123 Fake St., Faketown, CA;"
```

## 记录访问器

如果我们要写一个函数, 返回给定的记录的某一项, 大概是这样:

```haskell
getFirstName :: Entry -> String
getFirstName entry = entry.firstName
```

有个简单的语法糖可以避免我们编写这样的函数:

```bash
> address = { street: "123 Fake St.", city: "Faketown", state: "CA" }
> entry = { firstName: "John", lastName: "Smith", address: address }
> _.lastName entry
"Smith"
> _.address.city entry
"Faketown"
```

## 查询

我们写一个函数,输入姓名,查出地址:

```haskell
findEntry :: String -> String -> AddressBook -> Maybe Entry
findEntry firstName lastName book = head (filter filterEntry book)
  where
    filterEntry :: Entry -> Boolean
    filterEntry entry = entry.firstName == firstName && entry.lastName == lastName
```

我们看到了几个新东西, 首先是`head`和`filter`.这是两个`List`的处理函数,也定义在`Data.List`模块.

要引入它的话, 你应该把引入的部分改成:

```haskell
import Data.List (List(..), head, filter)
```

`head`是取`List`的第一个元素, `filter`接受两个参数, 第一个参数是一个函数, 第二个参数是一个`List`. 就像他的名字所说, 用函数过滤`List`.

按住`ctrl`, 点击函数, 就可以看到它的签名和实现.

接下来是`Maybe`, 这是一个类型, 就像`List`一样, 它也是一个泛型类型. 按住`ctrl`, 点击它, 也可以看到它的源码.

不只是类型和函数, 任何符号几乎都对应着源码的实现, 看源码是主要的学习方法, 通常这些源码都非常简短, 还带有注释, 不难看懂.

机会难得, 演示一下如何读代码吧.

### head

那么先看一下`head`的实现:

```haskell
head :: List ~> Maybe
head Nil = Nothing
head (x : _) = Just x
```

出现了一个奇怪的`~>`,`ctrl`点进去可以看到:

```haskell
type NaturalTransformation :: forall k. (k -> Type) -> (k -> Type) -> Type
type NaturalTransformation f g = forall a. f a -> g a

infixr 4 type NaturalTransformation as ~>
```

它是类型别名`NaturalTransformation`的中缀表达形式, 翻译一下就是`f ~> g`等价于`f a -> g a`.

那么我们的`List ~> Maybe`就是`List a -> Maybe a`.

也就是接受任意泛型的`List`类型, 返回同样类型是`Maybe`类型, 比如, 如果输入`List Int`类型, 就会返回`Maybe Int`类型.

实现也很简单, 如果输入的`List`是`Nil`, 就返回`Nothing`, 不然就取出`List`的第一个元素, 把他丢到`Just`里.

`Nothing`和`Just`是`Maybe`类型的构造子:

```haskell
data Maybe a = Nothing | Just a
```

### filter

再看看`filter`函数:

```haskell
filter :: forall a. (a -> Boolean) -> List a -> List a
filter p = go Nil
  where
  go acc Nil = reverse acc
  go acc (x : xs)
    | p x = go (x : acc) xs
    | otherwise = go acc xs
```

有一个`reverse`函数和一个竖线的奇怪写法.

#### 卫兵模式

先解释一下`卫兵模式`(Guards).

简单的说,就是条件判断:

```haskell
  go acc (x : xs)
    | p x = go (x : acc) xs
    | otherwise = go acc xs
```

`go`是函数名, `acc`是第一个参数, `(x : xs)`是模式匹配, 其中的`:`是`Cons`的中缀符号, `ctrl`点进去可以看到:

```haskell
data List a = Nil | Cons a (List a)

infixr 6 Cons as :
```

下面的`| p x = go (x : acc) xs`表示, 如果`p x`为真, 则返回`go (x : acc) xs`.否则, 向下继续执行.

下面的`| otherwise = go acc xs`表示, 如果执行到这了, 就返回`go acc xs`.

卫兵模式类似于`if-elif-else`模式.

#### reverse

点进`reverse`可以看到:

```haskell
reverse :: List ~> List
reverse = go Nil
  where
  go acc Nil = acc
  go acc (x : xs) = go (x : acc) xs
```

`List ~> List`已经说过, 它等价于`List a -> List a`, 即, 输入一个任意泛型的`List`, 返回同类型的`List`. 比如输入`List Int`, 就会返回`List Int`.

下面这里用了`point-free`模式, 完整的写法是`reverse a = go Nil a`, 其中`a`就是输入的`List`.

然后`go`是一个函数, 在下面的`where`部分定义了:

如果输入的第二个参数(也就是我们输入的List)是Nil的话, 直接返回第一个参数.

否则, 把第一项取出来, 拼接到第一个参数上, 把这个作为第一个参数, 把剩余的项作为第二个参数, 递归调用`go`函数.

可以看到,这样会把`List`反转.

#### 结论

再看开始的这个`filter`:

```haskell
filter :: forall a. (a -> Boolean) -> List a -> List a
filter p = go Nil
  where
  go acc Nil = reverse acc
  go acc (x : xs)
    | p x = go (x : acc) xs
    | otherwise = go acc xs
```

先看参数, 接受两个参数, 第一个是一个接受任意类型, 返回布尔值的函数, 第二个是一个任意泛型的`List`,然后会返回同类型的`List`.

它也用了`point-free`写法, 完整的写法是`filter p a = go Nil a`,其中`p`是传入的函数, `a`是输入的`List`.

接下来调用`go`函数, 我们输入的`List`是被作为第二个参数传入的.

然后`go`函数的定义在`where`里:

接收两个参数, 如果第二个参数为空, 就反转第一个参数.

否则, 先用模式匹配把第二个参数的第一项取出来, 传给函数`p`.

如果`p`返回真, 就把这项拼接到第一个参数里, 然后把它作为第一参数, 把剩余项作为第二参数, 递归调用`go`函数.

如果`p`返回假, 就抛弃这项, 用剩余项递归调用`go`函数.

### 结论

都解释清楚了, 再来看一开始这个函数.

```haskell
findEntry :: String -> String -> AddressBook -> Maybe Entry
findEntry firstName lastName book = head (filter filterEntry book)
  where
    filterEntry :: Entry -> Boolean
    filterEntry entry = entry.firstName == firstName && entry.lastName == lastName
```

输入姓名,通讯录,返回一个`Maybe Entry`, 就是被`Maybe`包裹的通讯录项.

实现很简单, 按`filterEntry`将输入的通讯录过滤, 并取它的第一个项.

而`filterEntry`定义在`where`里:输入一个通讯录项, 判断姓名是否符合我们传入的姓名, 符合返回真, 不符合返回假.

这样自然就找到了匹配姓名的那个条目.

### 函数组合

另外

可以用另一种写法:

```haskell
findEntry firstName lastName book = (head <<< filter filterEntry) book
```

这个`<<<`符号是函数组合, 对于两个单参数函数, 是可以组合的.

例如, `f(x) = a(b(x))`的意思是, 函数f有一个参数, 这个参数会被b计算, 得到的结果再被a计算.

这样我们就把函数`a`,`b`组合成了函数`f`.如果写作箭头就是`(a <<< b)`.

虽然`filter`并不是单参函数, 但因为柯里化, 输入了`filterEntry`后, `filter filterEntry`已经是单参函数了.

这样处理后, 还可以再使用一次`point-free`形式:

```haskell
findEntry firstName lastName = (head <<< filter filterEntry)
```

另外, 你也可以写:

```haskell
findEntry firstName lastName = (filter filterEntry >>> head)
```

不同的组合方向而已.

## 测试

现在, 我们可以通过`findEntry`查找通讯录的人了, 但它返回的是一个`Maybe Entry`.

我们要测试的话, 只能打印出字符串, 所以我们得写一个`Maybe Entry`转字符串的函数.

```haskell
showMaybeEntry :: Maybe Entry -> String
showMaybeEntry Nothing = "Nothing"
showMaybeEntry (Just a) = "Just (" <> showEntry a <> ")"
```

现在你的文件大概是这样:

```haskell
module Main where

import Prelude

import Data.List (List(..), head, filter)
import Data.Maybe (Maybe(..))
import Effect (Effect)
import Effect.Console (log)

type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }

type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }

type AddressBook = List Entry

showEntry :: Entry -> String
showEntry entry = entry.lastName <> ", " <> entry.firstName <> ": " <> showAddress entry.address

showAddress :: Address -> String
showAddress addr = addr.street <> ", " <> addr.city <> ", " <> addr.state

emptyBook :: AddressBook
emptyBook = Nil

insertEntry :: Entry -> AddressBook -> AddressBook
insertEntry = Cons

showAddressBook :: AddressBook -> String
showAddressBook Nil = ""
showAddressBook (Cons entry book) = showEntry entry <> ";" <> showAddressBook book

findEntry :: String -> String -> AddressBook -> Maybe Entry
findEntry firstName lastName book = head (filter filterEntry book)
  where
    filterEntry :: Entry -> Boolean
    filterEntry entry = entry.firstName == firstName && entry.lastName == lastName

showMaybeEntry :: Maybe Entry -> String
showMaybeEntry Nothing = "Nothing"
showMaybeEntry (Just a) = "Just (" <> showEntry a <> ")"

main :: Effect Unit
main = do
  log "🍝"
```

好了, 来测试:

```bash
> address = { street: "123 Fake St.", city: "Faketown", state: "CA" }
> entry = { firstName: "John", lastName: "Smith", address: address }
> newBook = insertEntry entry emptyBook
> findData = findEntry "John" "Smith" newBook 
> showMaybeEntry findData    
"Just (Smith, John: 123 Fake St., Faketown, CA)"
> showMaybeEntry ( findEntry "aaa" "bbb" newBook )              
"Nothing"
```

## 运行

如果不想折腾交互模式了, 可以写到源码里, 直接运行:

```haskell
module Main where

import Prelude

import Data.List (List(..), head, filter)
import Data.Maybe (Maybe(..))
import Effect (Effect)
import Effect.Console (log)

type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }

type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }

type AddressBook = List Entry

showEntry :: Entry -> String
showEntry entry = entry.lastName <> ", " <> entry.firstName <> ": " <> showAddress entry.address

showAddress :: Address -> String
showAddress addr = addr.street <> ", " <> addr.city <> ", " <> addr.state

emptyBook :: AddressBook
emptyBook = Nil

insertEntry :: Entry -> AddressBook -> AddressBook
insertEntry = Cons

showAddressBook :: AddressBook -> String
showAddressBook Nil = ""
showAddressBook (Cons entry book) = showEntry entry <> ";" <> showAddressBook book

findEntry :: String -> String -> AddressBook -> Maybe Entry
findEntry firstName lastName book = head (filter filterEntry book)
  where
    filterEntry :: Entry -> Boolean
    filterEntry entry = entry.firstName == firstName && entry.lastName == lastName

showMaybeEntry :: Maybe Entry -> String
showMaybeEntry Nothing = "Nothing"
showMaybeEntry (Just a) = "Just (" <> showEntry a <> ")"

address :: Address
address = { street: "123 Fake St.", city: "Faketown", state: "CA" }

entryData :: Entry
entryData = { firstName: "John", lastName: "Smith", address: address }

newBook :: AddressBook
newBook = insertEntry entry emptyBook

main :: Effect Unit
main = do
  log (showMaybeEntry (findEntry "John" "Smith" newBook))
```

现在使用`spago run`运行:

```bash
$ spago run
[info] Build succeeded.
Just (Smith, John: 123 Fake St., Faketown, CA)
```

### 美元符

因为运算优先级的问题, `log`这里的括号是必须的.

如果不加括号, 例如这样: `log showMaybeEntry findEntry "John" "Smith" newBook`.

就会变成, 用`showMaybeEntry`去调用`log`, 得到的值会是一个函数, 再用`findEntry`调用这个函数, 等等...

幸运的是, 有个符号可以解决这个问题:

```haskell
apply :: forall a b. (a -> b) -> a -> b
apply f x = f x

infixr 0 apply as $
```

有一个函数, `apply`, 它接收两个参数, 第一个是函数, 第二个是值, 它以值调用函数. 其实他什么都没做.

但重定义为最低优先级后, 就出现了神奇的效果.

```haskell
  log $ showMaybeEntry (findEntry "John" "Smith" newBook)
```

因为`$`的优先级最低, 所以它左边的归左边, 右边的归右边, 只有左右都完成后, 才会用左调用右.

这效果, 等价于把右边的所有内容加个括号.

可以进一步简化:

```haskell
  log $ showMaybeEntry $ findEntry "John" "Smith" newBook
```

漂亮多了.
