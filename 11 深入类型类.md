# 深入类型类

本章我们看看更多更复杂的类型类.

## 类型类定义

上一章我们只是给了简单的类型类写法, 现在我们要扩充这个概念.

来看看`Functor`的定义:

```haskell
class Functor f where
  map :: forall a b. (a -> b) -> f a -> f b
```

其实这里的map定义是一种简写, 完整的写法是

```
map :: forall (a :: Type) (b :: Type). (a -> b) -> f a -> f b
```

默认情况下, 你写的函数泛型的kind都是Type.

鼠标放在Functor上, 也可以看到: Functor :: (Type → Type) → Constraint.

这意味着, 如果某个类型要实现Functor, 这个类型的kind类型应该是(Type → Type).

为什么Functor是(Type → Type) → Constraint?

因为下面map里写的a和b都是Type, 而箭头(->)只能把两个kind类型是Type的类型相连, 所以编译器自动推导出了f是Type->Type.

为什么箭头(->)只能把两个kind类型是Type的类型相连? 我们下面会说到.

来看一个实现, 和定义摆在一起看看:

```haskell
class Functor f where
  map :: forall a b. (a -> b) -> f a -> f b

instance functorMaybe :: Functor Maybe where
  map fn (Just x) = Just (fn x)
  map _  _        = Nothing
```

注意到这里写的是`Functor Maybe where`而不是`Functor Maybe a where`. 证明了我们刚才说的, 实现Functor的类型的kind类型是Type->Type.

在实现里, 我们把Maybe填在了f的位置上, 意味着, Maybe的map函数的签名应该是, 把定义的签名:

```haskell
  map :: forall a b. (a -> b) -> f a -> f b
```

中的f全都换成Maybe:

```haskell
  map :: forall a b. (a -> b) -> Maybe a -> Maybe b
```

这很重要, 下面的讨论较为复杂, 我们需要这种形式的力量才不至于迷失.

## Semigroupoid

来看一个复杂的类型类

```haskell
-- | A `Semigroupoid` is similar to a [`Category`](#category) but does not
-- | require an identity element `identity`, just composable morphisms.
-- |
-- | `Semigroupoid`s must satisfy the following law:
-- |
-- | - Associativity: `p <<< (q <<< r) = (p <<< q) <<< r`
-- |
-- | One example of a `Semigroupoid` is the function type constructor `(->)`,
-- | with `(<<<)` defined as function composition.
class Semigroupoid :: forall k. (k -> k -> Type) -> Constraint
class Semigroupoid a where
  compose :: forall b c d. a c d -> a b c -> a b d
```

翻译:

```
`Semigroupoid`类似于`Category`, 但它不需要单位元素, 只需要能组合.
必须符合定律:
- 结合律: p <<< (q <<< r) = (p <<< q) <<< r
一个例子是函数类型构造函数 (->), 它的`compose`是函数组合`(<<<)`.
```

先不用在意Category, 我们稍后会说到.

其实类型类也是有类型的, 而且可以手写, 看这里的类型类签名, 如果有某个类型要实现它, 这个类型的`kind`类型必须是`(k -> k -> Type)`.

然后它定义了一个函数, 叫`compose`, 它要求输入一个`a c d`和一个`a b c`, 返回一个`a b d`. 这里的`b c d`全是任意类型泛型, `a`是要实现类型类的类型.

别急, 我们有一个例子:

```haskell
instance semigroupoidFn :: Semigroupoid (->) where
  compose f g x = f (g x)
```

虽然是符号, 但根据之前的理论推测, 我们知道, 这个`->`就是一个类型, 并且知道这个类型的`kind`类型是`(k -> k -> Type)`.

```bash
> :k (->) 
Type -> Type -> Type
```

经过一番查找, 找到这里:

https://pursuit.purescript.org/builtins/docs/Prim#t:Function

```haskell
Function

data Function :: Type -> Type -> Type

A function, which takes values of the type specified by the first type parameter, and returns values of the type specified by the second. In the JavaScript backend, this is a standard JavaScript Function.

The type constructor (->) is syntactic sugar for this type constructor. It is recommended to use (->) rather than Function, where possible.

That is, prefer this:

f :: Number -> Number
to either of these:

f :: Function Number Number
f :: (->) Number Number
```

好的, 就是说`->`是`Function`的中缀别名.

我们也可以这样写:

```haskell
f :: Function Int Int
f a = a + 1
```

一直在用的->居然也是泛型类型, 想想也合理, 和之前的例子对比一下:

```haskell
-- 这表示定义一个值, 名叫emptyBook, 类型是List Int
emptyBook :: List Int
emptyBook = Nil
-- 这表示定义一个值, 名叫f, 类型是Function Int Int
f :: Function Int Int
f a = a + 1
```

也就是说, 函数也是值.

同时我们看到了, Function是`Type -> Type -> Type`, 也就回答了我们上面"为什么箭头(->)只能把两个kind类型是Type的类型相连"的问题.

我们看不到`Function`类型的定义, 它内置在编译器里.

但我们至少知道, `Function`是一个类型, 并且知道他的`kind`类型是`Type -> Type -> Type`.

好, 我们回来, 结合这两个看看:

```haskell
class Semigroupoid a where
  compose :: forall b c d. a c d -> a b c -> a b d

instance semigroupoidFn :: Semigroupoid (->) where
  compose f g x = f (g x)
```

看一下类型类定义里compose的参数, 输入一个a c d, 和一个a b c, 得到一个a b d.

在->对它的实现里, ->处于a的位置, 而->又是Function的别名, 所以, 在->实现Semigroupoid中, compose的签名应该是:

```haskell
compose :: forall b c d. Function c d -> Function b c -> Function b d
```

那么, Function c d, Function b c, Function b d是什么? 就是函数类型, 分别是c->d, b->c, b->d.

也就是说, 在这里, compose输入一个c->d的函数和一个b->c的函数, 得到一个b->d的函数.

实现里的f g就分别是c->d, b->c.

那么x是什么? 是一个任意参数, 虽然我们刚才说compose只有两个参数, 但我可以传入多个参数的形式, 编译器可以自动推导.

所以, compose f g x等于, x先输入给g, 得到的结果再输入给f. 这就是函数组合.

之前我们看到过函数组合, 但为了便于理解, 举一个简单的例子:

```haskell
f1 :: Int -> Boolean
f1 a = if a > 5 then true else false

f2 :: Boolean -> String
f2 a = show a
```

```bash
> f3 = compose f2 f1
> :t f3
Int -> String
```

这里, f2就是c->d, f1就是b->c, f3就是b->d, b就是Int, c就是Boolean, d就是String.

就像你所想的, <<<就是compose的中缀符号.

```haskell
infixr 9 compose as <<<
```

## Category

上面它提到了Category, 我们来看看:

```haskell
-- | `Category`s consist of objects and composable morphisms between them, and
-- | as such are [`Semigroupoids`](#semigroupoid), but unlike `semigroupoids`
-- | must have an identity element.
-- |
-- | Instances must satisfy the following law in addition to the
-- | `Semigroupoid` law:
-- |
-- | - Identity: `identity <<< p = p <<< identity = p`
class Category :: forall k. (k -> k -> Type) -> Constraint
class Semigroupoid a <= Category a where
  identity :: forall t. a t t
```

翻译:

```
Category由对象和它们之间可组合的态射组成, 并且类似于Semigroupoids, 但是不同的是, 必须有单位元素.
还必须符合定律:
- identity <<< p = p <<< identity = p
```

先看签名, `(k -> k -> Type) -> Constraint`表示, 要实现它的类型的`kind`类型必须是`(k -> k -> Type)`, 其中`k`是任意类型.

下面的`class Semigroupoid a <= Category a where`说明, 如果某个类型要实现`Category`, 必须先实现`Semigroupoid`.

接下来它定义了一个值, identity, 意思是, 对于实现Category类型类的类型a, identity的类型是a t t.

举个例子, 如果Function实现了Category类型类的话, identity的类型就可以是Function Int Int或Function String String之类的.

注意写的是a t t, 所以Function Int String是不行的.

虽然我写的是Function Int Int, 但你应该知道, 这是Int->Int, 也就是输入Int并且返回Int的函数的类型.

也就是说, 如果Function实现Category类型类的话, identity就是个输入什么类型返回什么类型的函数, 签名是`t -> t`.

再看看定律, 如果我们把p想象为Function的话, 就是说有一个函数identity, 和已有函数组合, 无论是左组合还是右组合, 都不变.

而Function确实也实现了Category类型类:

```haskell
instance categoryFn :: Category (->) where
  identity x = x
```

跳过复杂的类型推理, 直接从字面理解好了.

按上面的分析, 如果Function实现Category的话, identity应该是一个函数.

那么现在需要让这个函数符合定律, 左右组合都不变, 很简单, 输入什么返回什么就可以了, 这也符合t -> t的签名.

## Functor

上一章说到了`Functor`, 我们再仔细看看:

```haskell
-- | A `Functor` is a type constructor which supports a mapping operation
-- | `map`.
-- |
-- | `map` can be used to turn functions `a -> b` into functions
-- | `f a -> f b` whose argument and return types use the type constructor `f`
-- | to represent some computational context.
-- |
-- | Instances must satisfy the following laws:
-- |
-- | - Identity: `map identity = identity`
-- | - Composition: `map (f <<< g) = map f <<< map g`
class Functor f where
  map :: forall a b. (a -> b) -> f a -> f b
```

两条定律翻译一下:

```
- 同一律: map identity == identity
- 结合律: map (f <<< g) == map f <<< map g
```

还是一点一点来, 先看签名, 虽然它没有写, 但鼠标放到上面就可以看到:

```haskell
Functor :: (Type -> Type) -> Constraint
```

要实现Function类型的kind类型都必须是(Type -> Type).

看看定义, 它定义了一个map函数, 接受一个a->b的函数, 返回一个输入f a类型, 返回一个f b类型的函数.

看看定律, 同一律写的是 map identity == identity, 从map的签名可以看出来, map的第一个参数是a->b的函数.

所以我们知道这里的identity是指Function的identity, 也就是那个输入什么返回什么的函数.

结合律是, 把两个函数组合后map, 等于分别map再组合, 我们之后会看到例子.

注意, Functor并没有继承Category, 只是Functor用到了实现Category的Function类型而已.

现在找一个实现, 用简单的Maybe看吧, 把定义和实现摆在一起:

```haskell
class Functor f where
  map :: forall a b. (a -> b) -> f a -> f b

instance functorMaybe :: Functor Maybe where
  map fn (Just x) = Just (fn x)
  map _  _        = Nothing
```

定义里的f, 在实现里的对应位置写的是Maybe, 所以Maybe实现的map的签名应该是:

```haskell
  map :: forall a b. (a -> b) -> Maybe a -> Maybe b
```

这里理解为, 输入一个a->b的函数, 再输入一个Maybe a的值, 得到一个Maybe b的值, 比较方便.

这个定义是模式匹配, 先看第一行.

fn匹配了输入的(a->b)的函数, Just x匹配了Maybe a.

最后得到Just (fn x), 也就是把x丢给fn, 因为fn的类型是a->b, 所以(fn x)就是b, 再用Just构造子构造成Maybe b类型的值. 符合签名.

这是匹配的一种情况, 另一种情况是, Maybe a并不是用Just构造的, 而是Nil, 那么直接返回Nothing. Nothing也可以看作Maybe b类型的值. 也符合签名.

来证明一下这样实现是符合定律的:

首先是同一律, 如果传入的函数是identity, 然后我们还有一个Maybe的值.

如果是Just构造的, 我们写 Just x, 会得到Just (identity x), 也就是Just (x), 符合定律.

如果是Nothing构造的, 会得到Nothing, 符合定律.

然后是结合律, 先看一下描述:

```haskell
map (f <<< g) == map f <<< map g
```

这等价于

```haskell
map (f <<< g) maybeData == (map f <<< map g) maybeData
```

其中, maybeData是Maybe任意泛型类型的值.

我们先考虑maybeData是Nothing构造的情况, 那么无论map (f <<< g)和(map f <<< map g)是什么, 左右两边都是Nothing, 符合定律.

再考虑maybeData是Just构造的情况, 我们写Just a. 同时我们知道g是a->b, f是b->c.

先看左边, 先看(f <<< g), 这个函数组合得到了一个新的函数, 签名是a->c.

再看看实现:

```haskell
map fn (Just x) = Just (fn x)
```

套用在`map (f <<< g) maybeData`上, 这里fn就是(f <<< g), Just (fn x)就是maybeData, 我们把他写成Just a,所以等价于:

```haskell
map (f <<< g) (Just a) = Just ((f <<< g) a)
```

那么, Just ((f <<< g) x)是什么, 依据函数实现compose的定义:

```haskell
compose f g x = f (g x)
```

可以得到, 最后答案是:

```haskell
Just (f (g a))
```

再看右边, `(map f <<< map g) maybeData`, 同样依据函数实现compose的定义, 可以得到:

```haskell
compose (map f) (map g) maybeData
```

也就是

```haskell
(map f) ((map g) maybeData)
```

我们知道maybeData是Just a, 所以可以写成:

```haskell
(map f) (map g (Just a))
```

看看Maybe的实现:

```haskell
map fn (Just x) = Just (fn x)
```

套进`(map g (Just a))`里, fn是g, x是a, 所以得到:

```haskell
(map f) (Just (g a))
```

注意到外层也是个map, fn是f, x是(g a), 再套一次实现, 得到:

```haskell
Just (f (g a))
```

左右相等, 证毕.

