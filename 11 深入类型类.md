# 深入类型类

本章我们看看更多更复杂的类型类.

## 类型类定义

上一章我们只是给了简单的类型类写法, 现在我们要扩充这个概念.

来看看`Functor`的定义:

```haskell
class Functor f where
  map :: forall a b. (a -> b) -> f a -> f b
```

其实这里的map定义是一种简写, 完整的写法是

```haskell
map :: forall (a :: Type) (b :: Type). (a -> b) -> f a -> f b
```

默认情况下, 你写的函数泛型的`kind类型`都是`Type`.

鼠标放在`Functor`上, 也可以看到: `Functor :: (Type -> Type) -> Constraint`.

这意味着, 如果某个类型要实现`Functor`, 这个类型的`kind类型`应该是`(Type → Type)`.

为什么`Functor`是`(Type -> Type) -> Constraint`?

因为下面`map`里写的`a`和`b`都是`Type`, 而箭头`->`只能把两个`kind类型`是`Type`的类型相连, 所以编译器自动推导出了`f`是`Type->Type`.

那为什么箭头`->`只能把两个`kind类型`是`Type`的类型相连? 我们下面会说到.

来看一个实现, 和定义摆在一起看看:

```haskell
class Functor f where
  map :: forall a b. (a -> b) -> f a -> f b

instance functorMaybe :: Functor Maybe where
  map fn (Just x) = Just (fn x)
  map _  _        = Nothing
```

注意到这里写的是`Functor Maybe where`而不是`Functor (Maybe a) where`. 证明了我们刚才说的, 实现`Functor`的类型的`kind类型`是`Type->Type`.

在实现里, 我们把`Maybe`填在了`f`的位置上, 意味着, `Maybe`的`map`函数的签名应该是, 把定义的签名:

```haskell
  map :: forall a b. (a -> b) -> f a -> f b
```

中的`f`全都换成`Maybe`:

```haskell
  map :: forall a b. (a -> b) -> Maybe a -> Maybe b
```

这很重要, 下面的讨论较为复杂, 我们需要这种形式的力量才不至于迷失.

## Semigroupoid

来看一个复杂的类型类

```haskell
-- | A `Semigroupoid` is similar to a [`Category`](#category) but does not
-- | require an identity element `identity`, just composable morphisms.
-- |
-- | `Semigroupoid`s must satisfy the following law:
-- |
-- | - Associativity: `p <<< (q <<< r) = (p <<< q) <<< r`
-- |
-- | One example of a `Semigroupoid` is the function type constructor `(->)`,
-- | with `(<<<)` defined as function composition.
class Semigroupoid :: forall k. (k -> k -> Type) -> Constraint
class Semigroupoid a where
  compose :: forall b c d. a c d -> a b c -> a b d
```

翻译:

```
`Semigroupoid`类似于`Category`, 但它不需要单位元素, 只需要能组合.
必须符合定律:
- 结合律: p <<< (q <<< r) = (p <<< q) <<< r
一个例子是函数类型构造函数 (->), 它的`compose`是函数组合`(<<<)`.
```

先不用在意`Category`, 我们稍后会说到.

其实类型类也是有类型的, 而且可以自己写, 看这里的类型类签名, 如果有某个类型要实现它, 这个类型的`kind类型`必须是`(k -> k -> Type)`.

然后它定义了一个函数, 叫`compose`, 它要求输入一个`a c d`和一个`a b c`, 返回一个`a b d`. 这里的`b c d`全是任意类型泛型, `a`是要实现类型类的类型.

别急, 我们有一个例子:

```haskell
instance semigroupoidFn :: Semigroupoid (->) where
  compose f g x = f (g x)
```

虽然是符号, 但根据之前的理论推测, 我们知道, 这个`->`就是一个类型, 并且知道这个类型的`kind类型`是`(k -> k -> Type)`.

```haskell
> :k (->) 
Type -> Type -> Type
```

经过一番查找, 找到这里:

https://pursuit.purescript.org/builtins/docs/Prim#t:Function

```haskell
Function

data Function :: Type -> Type -> Type

A function, which takes values of the type specified by the first type parameter, and returns values of the type specified by the second. In the JavaScript backend, this is a standard JavaScript Function.

The type constructor (->) is syntactic sugar for this type constructor. It is recommended to use (->) rather than Function, where possible.

That is, prefer this:

f :: Number -> Number
to either of these:

f :: Function Number Number
f :: (->) Number Number
```

好的, 就是说`->`是`Function`的中缀别名.

```haskell
-- 这两种写法是等价的
f :: Function Number Number
f :: (->) Number Number
```

一直在用的`->`居然也是泛型类型, 想想也合理, 和之前的例子对比一下:

```haskell
-- 这表示定义一个值, 名叫emptyBook, 类型是List Int
emptyBook :: List Int
emptyBook = Nil

-- 这表示定义一个值, 名叫f, 类型是Function Int Int
f :: Function Int Int
f a = a + 1
```

也就是说, 函数也是值.

同时我们看到了, `Function`是`Type -> Type -> Type`, 也就回答了我们上面"为什么箭头`->`只能把两个kind类型是Type的类型相连"的问题.

我们看不到`Function`类型的定义, 它内置在编译器里.

但我们至少知道, `Function`是一个类型, 并且知道他的`kind`类型是`Type -> Type -> Type`.

好, 我们回来, 结合这两个看看:

```haskell
class Semigroupoid a where
  compose :: forall b c d. a c d -> a b c -> a b d

instance semigroupoidFn :: Semigroupoid (->) where
  compose f g x = f (g x)
```

看一下类型类定义里`compose`的参数, 输入一个`a c d`, 和一个`a b c`, 得到一个`a b d`.

在`->`对它的实现里, `->`处于`a`的位置, 而`->`又是`Function`的别名, 所以, 在`->`实现`Semigroupoid`中, `compose`的签名应该是:

```haskell
compose :: forall b c d. Function c d -> Function b c -> Function b d
```

那么, `Function c d`, `Function b c`, `Function b d`是什么? 就是函数类型, 分别是`c->d`, `b->c`, `b->d`.

也就是说, 在这里, `compose`输入一个`c->d`的函数和一个`b->c`的函数, 得到一个`b->d`的函数.

实现

```haskell
instance semigroupoidFn :: Semigroupoid (->) where
  compose f g x = f (g x)
```

里的`f`, `g`就分别是`c->d`, `b->c`.

那么`x`是什么? 是一个任意参数, 虽然我们刚才说`compose`只有两个参数, 但我可以传入多个参数的形式, 编译器可以自动推导.

所以, `compose f g x`等于, `x`先输入给`g`, 得到的结果再输入给`f`. 这就是函数组合.

之前我们看到过函数组合, 但为了便于理解, 举一个简单的例子:

```haskell
f1 :: Int -> Boolean
f1 a = if a > 5 then true else false

f2 :: Boolean -> String
f2 a = show a
```

```bash
> f3 = compose f2 f1
> :t f3
Int -> String
```

这里, `f2`就是`c->d`, `f1`就是`b->c`, `f3`就是`b->d`, `b`就是`Int`, `c`就是`Boolean`, `d`就是`String`.

就像你所想的, `<<<`就是`compose`的中缀符号.

```haskell
infixr 9 compose as <<<
```

## Category

上面它提到了`Category`, 我们来看看:

```haskell
-- | `Category`s consist of objects and composable morphisms between them, and
-- | as such are [`Semigroupoids`](#semigroupoid), but unlike `semigroupoids`
-- | must have an identity element.
-- |
-- | Instances must satisfy the following law in addition to the
-- | `Semigroupoid` law:
-- |
-- | - Identity: `identity <<< p = p <<< identity = p`
class Category :: forall k. (k -> k -> Type) -> Constraint
class Semigroupoid a <= Category a where
  identity :: forall t. a t t
```

翻译:

```
`Category`由对象和它们之间可组合的态射组成, 并且类似于`Semigroupoids`, 但是不同的是, 必须有单位元素.
还必须符合定律:
- identity <<< p = p <<< identity = p
```

先看签名, `(k -> k -> Type) -> Constraint`表示, 要实现它的类型的`kind类型`必须是`(k -> k -> Type)`, 其中`k`是任意类型.

下面的`class Semigroupoid a <= Category a where`说明, 如果某个类型要实现`Category`, 必须先实现`Semigroupoid`.

接下来它定义了一个值, `identity`, 意思是, 对于实现`Category`类型类的类型`a`, `identity`的类型是`a t t`.

举个例子, 如果`Function`实现了`Category`类型类的话, `identity`的类型就可以是`Function Int Int`或`Function String String`之类的.

注意写的是`a t t`, 所以`Function Int String`是不行的.

虽然我写的是`Function Int Int`, 但你应该知道, 这是`Int->Int`, 也就是输入`Int`并且返回`Int`的函数的类型.

也就是说, 如果`Function`实现`Category`类型类的话, `identity`就是个输入什么类型返回什么类型的函数, 签名是`t -> t`.

再看看定律, 如果我们把`p`想象为`Function`的话, 就是说有一个函数`identity`, 和已有函数组合, 无论是左组合还是右组合, 都不变.

而`Function`确实也实现了`Category`类型类:

```haskell
instance categoryFn :: Category (->) where
  identity x = x
```

跳过复杂的类型推理, 直接从字面理解好了.

按上面的分析, 如果`Function`实现`Category`的话, `identity`应该是一个函数.

那么现在需要让这个函数符合定律, 左右组合都不变, 很简单, 输入什么返回什么就可以了, 这也符合`t -> t`的签名.

## Functor

上一章说到了`Functor`, 我们再仔细看看:

```haskell
-- | A `Functor` is a type constructor which supports a mapping operation
-- | `map`.
-- |
-- | `map` can be used to turn functions `a -> b` into functions
-- | `f a -> f b` whose argument and return types use the type constructor `f`
-- | to represent some computational context.
-- |
-- | Instances must satisfy the following laws:
-- |
-- | - Identity: `map identity = identity`
-- | - Composition: `map (f <<< g) = map f <<< map g`
class Functor f where
  map :: forall a b. (a -> b) -> f a -> f b
```

两条定律翻译一下:

```
- 同一律: map identity == identity
- 结合律: map (f <<< g) == map f <<< map g
```

还是一点一点来, 先看签名, 虽然它没有写, 但鼠标放到上面就可以看到:

```haskell
Functor :: (Type -> Type) -> Constraint
```

要实现`Function`类型的`kind类型`都必须是`(Type -> Type)`.

看看定义, 它定义了一个`map`函数, 接受一个`a->b`的函数, 返回一个函数, 这个函数输入`f a`类型的值, 返回一个`f b`类型的值.

看看定律, 同一律写的是 `map identity == identity`, 从`map`的签名可以看出来, `map`的第一个参数是`a->b`的函数.

所以我们知道这里的`identity`是指`Function`的`identity`, 也就是那个输入什么返回什么的函数.

结合律是, 把两个函数组合后`map`, 等于分别`map`再组合, 我们之后会看到例子.

注意, `Functor`并没有继承`Category`, 只是`Functor`用到了实现`Category`的`Function`类型而已.

### 实现

现在找一个实现, 用简单的`Maybe`看吧, 把定义和实现摆在一起:

```haskell
class Functor f where
  map :: forall a b. (a -> b) -> f a -> f b

instance functorMaybe :: Functor Maybe where
  map fn (Just x) = Just (fn x)
  map _  _        = Nothing
```

### 签名

定义里的`f`, 在实现里的对应位置写的是`Maybe`, 所以`Maybe`实现的`map`的签名应该是:

```haskell
  map :: forall a b. (a -> b) -> Maybe a -> Maybe b
```

可以理解为, 输入一个`a->b`的函数, 再输入一个`Maybe a`的值, 得到一个`Maybe b`的值.

这个定义是模式匹配, 先看第一行. `fn`匹配了输入的`(a->b)`的函数, `Just x`匹配了`Maybe a`.

最后得到`Just (fn x)`, 也就是把`x`输入`fn`, 因为`fn`的类型是`a->b`, 所以`(fn x)`的类型就是`b`, 再用`Just`构造子构造成`Maybe b`类型的值. 符合签名.

这是匹配的一种情况, 另一种情况是, `Maybe a`并不是用`Just`构造的, 而是`Nil`, 那么直接返回`Nothing`. `Nothing`也可以看作`Maybe b`类型的值. 也符合签名.

### 定律

来证明一下这样实现是符合定律的:

#### 同一律

```haskell
-- 原式
map identity == identity

-- 写成完整形式
map identity maybeData == identity maybeData

-- 如果maybeData是Nothing. 那么:
-- 左边, 由Maybe对map的实现, 会得到Nothing.
-- 右边, 由identity的实现, 会得到Nothing.
-- 左边 = 右边, 原式成立.

-- 如果maybeData是Just构造的值, 设它的类型是Maybe a, 写作Just x, 其中x是a类型的值. 那么:
-- 左边
  map identity (Just x)
= Just (identity x)       -- 由Maybe对map的实现
= Just x                  -- 由Function对identity的实现

-- 右边
  identity (Just x)
= Just x                  -- 由Maybe对map的实现

-- 左边 = 右边, 原式成立.
```

#### 结合律

```haskell
-- 原式
map (f <<< g) == map f <<< map g

-- 写成完整形式
map (f <<< g) maybeData == (map f <<< map g) maybeData

-- 如果maybeData是Nothing. 那么:
-- 无论左边的map (f <<< g)是什么, 左边都会得到Nothing.
-- 无论右边的(map f <<< map g)是什么, 都会得到Nothing.
-- 左边 = 右边, 原式成立.

-- 如果maybeData是Just构造的值, 设它的类型是Maybe a, 写作Just x, 其中x是a类型的值. 那么:
-- 左边
  map (f <<< g) (Just x)
= Just ((f <<< g) x)                  -- 由Maybe对map的实现
= Just (compose f g x)                -- 把中缀符号换成前缀函数
= Just (f (g x))                      -- 由Function对compose的实现

-- 右边
  (map f <<< map g) (Just x)
= compose (map f) (map g) (Just x)    -- 把中缀符号换成前缀函数
= (map f) (map g (Just x))            -- 由Function对compose的实现
= (map f) (Just g x)                  -- 由Maybe对map的实现
= Just (f (g x))                      -- 由Maybe对map的实现

-- 左边 = 右边, 原式成立.
```

