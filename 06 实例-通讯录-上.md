# 实例-通讯录-上

有了上面关于类型和函数的理解, 我们做一个通讯录来展示更多的设定.

## 需求分析

通讯录就是,记录人的地址.

我们可以给通讯录里加入一个新的记录, 也可以通过人名查找这个人的地址.

## 类型别名

我们先定义一个类型,表示通讯录中的一条记录,它有姓,名和地址.

```haskell
type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }
```

其中地址是另一个类型:包括街道,城市,国家.

```haskell
type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }
```

接下来,我们定义通讯录,它是"通讯录记录"组成的`List`:

```haskell
type AddressBook = List Entry
```

所以`type`关键词的逻辑很简单,就是做一个别名.

所以我们定义了三个类型:

- 通讯录记录: `Entry`
- 地址: `Address`
- 通讯录: `AddressBook`

## 依赖库

注意上面出现的`List`,这是一个类型.

如果你把上面的代码写入文件,如果代码提示正常工作,你会看到List下面有红线,告诉你`Unknown type List`.

在之前的章节中, 我们自己定义了`List`, 但其实官方有实现过, 还提供了一些帮助函数, 我们直接引入就可以了.

只要去它的库图书馆(https://pursuit.purescript.org)里搜索相关关键词,就可以找到对应的库,这里我们找到List:

https://pursuit.purescript.org/packages/purescript-lists/6.0.1

进而找到它的安装方法:

```bash
spago install lists
```

安装它.然后编译一下:

```bash
spago build
```

然后在文件中引入这个类型.

```haskell
import Data.List (List)
```

这里,`Data.List`是模块名,括号里的`List`是这个模块导出的一个类型,我们目前只引入这个类型.

最后,你的文件看起来像是这样:

```haskell
module Main where

import Prelude
import Effect (Effect)
import Effect.Console (log)
import Data.List (List)

type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }

type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }

type AddressBook = List Entry

main :: Effect Unit
main = do
  log "🍝"
```

## 显示函数

### 显示地址

现在,我们编写一个函数来把`Address`类型转换为字符串, 因为只有字符串才能被打印.

虽然也有更方便的方法, 但作为教学, 我们先自己写.

```haskell
showAddress :: Address -> String
showAddress addr = addr.street <> ", " <> addr.city <> ", " <> addr.state
```

其中, `addr.street`是从`addr`这个记录里取`street`这个记录, 之前已经演示过了.

### 中缀运算符

而`<>`是一个`中缀运算符`.

这里的规定是, 我可以给函数对应一个符号. 然后这个符号就是中缀的, 而函数依然是前缀的. (如果你熟悉c++, 这就是运算符重载.)

比如这里的`<>`,对应的函数是`append`.它的作用是, 字符串连接.

也就是说, 也可以写成这样:

```haskell
showAddress :: Address -> String
showAddress addr = append (append (append (append addr.street ", ") addr.city) ", ") addr.state
```

这是定义中缀符号的写法:

```haskell
infixr 5 append as <>
```

`infixr`表示右结合, `5`是优先级, 数字越大优先级越高, 接下来就是函数名字和符号了.

你可以在交互模式里试试:

```bash
> append "a" "b"
"ab"

> "a" <>  "b"   
"ab"
```

这两者是等价的, 只是写法不同而已.

顺便一提, 你也可以用这种形式把函数中缀调用, 或把符号前缀调用:

```bash
> "a" `append` "b"
"ab"

> (<>) "a" "b"    
"ab"
```

### 显示通讯录条目

同样的, 写出通讯录条目转字符串的函数:

```haskell
showEntry :: Entry -> String
showEntry entry = entry.lastName <> ", " <> entry.firstName <> ": " <> (showAddress entry.address)
```

他调用了`showAddress`来显示地址.

### 完成

现在你的文件长这样:

```haskell
module Main where

import Prelude
import Effect (Effect)
import Effect.Console (log)
import Data.List (List)

type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }

type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }

type AddressBook = List Entry

showEntry :: Entry -> String
showEntry entry = entry.lastName <> ", " <> entry.firstName <> ": " <> showAddress entry.address

showAddress :: Address -> String
showAddress addr = addr.street <> ", " <> addr.city <> ", " <> addr.state

main :: Effect Unit
main = do
  log "🍝"

```

## 测试

现在,先编译一下:

```bash
spago build
```

然后进入交互模式, 引入`Main`模块:

```bash
> import Main
```

接下来, 我们构造数据分别测试一下这两个函数:

```bash
> address = { street: "123 Fake St.", city: "Faketown", state: "CA" }
> showAddress address
"123 Fake St., Faketown, CA"

> entry = { firstName: "John", lastName: "Smith", address: address }
> showEntry entry
"Smith, John: 123 Fake St., Faketown, CA"
```

ok, 完美运行.