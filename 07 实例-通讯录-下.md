# å®ä¾‹-é€šè®¯å½•-ä¸‹

## åˆ›å»ºç©ºé€šè®¯å½•

æˆ‘ä»¬å…ˆåˆ›å»ºä¸€ä¸ªæ•°æ®, ä½œä¸ºç©ºçš„é€šè®¯å½•, å¹¶ä¸”è¯´æ˜å®ƒçš„ç±»å‹æ˜¯`AddressBook`:

```haskell
emptyBook :: AddressBook
emptyBook = Nil
```

ç°åœ¨`Nil`è¿˜ä¸èƒ½ä½¿ç”¨,éœ€è¦åœ¨å¼•å…¥çš„æ—¶å€™,è¯´æ˜è¦å¼•å…¥`List`çš„`Nil`æ„é€ å­.

```haskell
import Data.List (List(Nil))
```

å¦‚æœè¿˜æƒ³å¼•å…¥`Cons`æ„é€ å­, å¯ä»¥

```haskell
import Data.List (List(Nil, Cons))
```

å¦‚æœè¦å¼•å…¥å…¨éƒ¨æ„é€ å­, å¯ä»¥

```haskell
import Data.List (List(..))
```

ç°åœ¨ä½ çš„æ–‡ä»¶å¤§æ¦‚é•¿è¿™æ ·:

```haskell
module Main where

import Prelude
import Effect (Effect)
import Effect.Console (log)
import Data.List (List(..))

type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }

type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }

type AddressBook = List Entry

showEntry :: Entry -> String
showEntry entry = entry.lastName <> ", " <> entry.firstName <> ": " <> showAddress entry.address

showAddress :: Address -> String
showAddress addr = addr.street <> ", " <> addr.city <> ", " <> addr.state

emptyBook :: AddressBook
emptyBook = Nil

main :: Effect Unit
main = do
  log "ğŸ"
```

## æ’å…¥

ç°åœ¨æˆ‘ä»¬å†™ä¸€ä¸ªå‡½æ•°, å®ƒæ¥å—ä¸€ä¸ªé€šè®¯å½•æ¡ç›®(`Entry`)å’Œä¸€ä¸ªé€šè®¯å½•(`AddressBook`), è¿”å›å¦ä¸€ä¸ªé€šè®¯å½•(`AddressBook`).

```haskell
insertEntry :: Entry -> AddressBook -> AddressBook
insertEntry entry book = Cons entry book
```

å½“ç„¶ä½ ä¹Ÿå¯ä»¥æŠŠä»–å†™æˆ`point-free`å½¢å¼,å¯ä»¥åˆ†åˆ«æŠŠ`book`å’Œ`entry`éƒ½çº¦æ‰:

```haskell
insertEntry :: Entry -> AddressBook -> AddressBook
insertEntry = Cons
```

é™¤æ­¤ä»¥å¤–, æˆ‘ä»¬è¿˜éœ€è¦æœ‰ä¸€ä¸ªæŠŠé€šè®¯å½•è½¬æ¢æˆå­—ç¬¦ä¸²çš„å‡½æ•°.

```haskell
showAddressBook :: AddressBook -> String
showAddressBook Nil = ""
showAddressBook (Cons entry book) = showEntry entry <> ";" <> showAddressBook book
```

ç°åœ¨ä½ çš„æ–‡ä»¶å¤§æ¦‚æ˜¯è¿™æ ·:

```haskell
module Main where

import Prelude
import Effect (Effect)
import Effect.Console (log)
import Data.List (List(..))

type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }

type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }

type AddressBook = List Entry

showAddress :: Address -> String
showAddress addr = addr.street <> ", " <> addr.city <> ", " <> addr.state

showEntry :: Entry -> String
showEntry entry = entry.lastName <> ", " <> entry.firstName <> ": " <> (showAddress entry.address)

emptyBook :: AddressBook
emptyBook = Nil

insertEntry :: Entry -> AddressBook -> AddressBook
insertEntry = Cons

showAddressBook :: AddressBook -> String
showAddressBook Nil = ""
showAddressBook (Cons entry book) = showEntry entry <> ";" <> showAddressBook book

main :: Effect Unit
main = do
  log "ğŸ"
```

è¯•è¯•:

```bash
> address = { street: "123 Fake St.", city: "Faketown", state: "CA" }
> entry = { firstName: "John", lastName: "Smith", address: address }
> showAddressBook (insertEntry entry emptyBook)                      
"Smith, John: 123 Fake St., Faketown, CA;"
```

## æŸ¥è¯¢

æˆ‘ä»¬å†™ä¸€ä¸ªå‡½æ•°,è¾“å…¥å§“å,æŸ¥å‡ºåœ°å€:

```haskell
findEntry :: String -> String -> AddressBook -> Maybe Entry
findEntry firstName lastName book = head (filter filterEntry book)
  where
    filterEntry :: Entry -> Boolean
    filterEntry entry = entry.firstName == firstName && entry.lastName == lastName
```

æˆ‘ä»¬çœ‹åˆ°äº†å‡ ä¸ªæ–°ä¸œè¥¿, é¦–å…ˆæ˜¯`head`å’Œ`filter`.è¿™æ˜¯ä¸¤ä¸ª`List`çš„å¤„ç†å‡½æ•°,ä¹Ÿå®šä¹‰åœ¨`Data.List`æ¨¡å—.

è¦å¼•å…¥å®ƒä»¬çš„è¯, ä½ åº”è¯¥æŠŠå¼•å…¥çš„éƒ¨åˆ†æ”¹æˆ:

```haskell
import Data.List (List(..), head, filter)
```

å…¶ä¸­`head`æ˜¯å–`List`çš„ç¬¬ä¸€ä¸ªå…ƒç´ , `filter`æ¥å—ä¸¤ä¸ªå‚æ•°, ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªå‡½æ•°, ç¬¬äºŒä¸ªå‚æ•°æ˜¯ä¸€ä¸ª`List`. å°±åƒä»–çš„åå­—æ‰€è¯´, ç”¨å‡½æ•°è¿‡æ»¤`List`.

æŒ‰ä½`ctrl`, ç‚¹å‡»å‡½æ•°, å°±å¯ä»¥çœ‹åˆ°å®ƒçš„ç­¾åå’Œå®ç°.

æ¥ä¸‹æ¥æ˜¯`Maybe`, è¿™æ˜¯ä¸€ä¸ªç±»å‹, å°±åƒ`List`ä¸€æ ·, å®ƒä¹Ÿæ˜¯ä¸€ä¸ªæ³›å‹ç±»å‹. æŒ‰ä½`ctrl`, ç‚¹å‡»å®ƒ, ä¹Ÿå¯ä»¥çœ‹åˆ°å®ƒçš„æºç .

ä¸åªæ˜¯ç±»å‹å’Œå‡½æ•°, ä»»ä½•ç¬¦å·å‡ ä¹éƒ½å¯¹åº”ç€æºç çš„å®ç°, çœ‹æºç æ˜¯ä¸»è¦çš„å­¦ä¹ æ–¹æ³•, é€šå¸¸è¿™äº›æºç éƒ½éå¸¸ç®€çŸ­, è¿˜å¸¦æœ‰æ³¨é‡Š, ä¸éš¾çœ‹æ‡‚.

ä¹‹åæˆ‘ä»¬ä¼šå»è¯»è¿™äº›æºç , è¿™é‡Œæˆ‘ä»¬æŠŠæ³¨æ„åŠ›æ”¾åœ¨`findEntry`å‡½æ•°ä¸Š.

å…ˆçœ‹ç­¾å,è¾“å…¥å§“,å,é€šè®¯å½•,ç„¶åè¿”å›ä¸€ä¸ª`Maybe Entry`.

çœ‹å®ç°, æŒ‰`filterEntry`å°†è¾“å…¥çš„é€šè®¯å½•è¿‡æ»¤, å¹¶å–å®ƒçš„ç¬¬ä¸€ä¸ªé¡¹.

è€Œ`filterEntry`å®šä¹‰åœ¨`where`é‡Œ:è¾“å…¥ä¸€ä¸ªé€šè®¯å½•é¡¹, åˆ¤æ–­å§“åæ˜¯å¦ç¬¦åˆæˆ‘ä»¬ä¼ å…¥çš„å§“å, ç¬¦åˆè¿”å›çœŸ, ä¸ç¬¦åˆè¿”å›å‡.

è¿™æ ·è‡ªç„¶å°±æ‰¾åˆ°äº†åŒ¹é…å§“åçš„é‚£ä¸ªæ¡ç›®.

### å‡½æ•°ç»„åˆ

å¦å¤–

å¯ä»¥ç”¨å¦ä¸€ç§å†™æ³•:

```haskell
findEntry firstName lastName book = (head <<< filter filterEntry) book
```

è¿™ä¸ª`<<<`ç¬¦å·æ˜¯å‡½æ•°ç»„åˆ, å¯¹äºä¸¤ä¸ªå•å‚æ•°å‡½æ•°, æ˜¯å¯ä»¥ç»„åˆçš„.

ä¾‹å¦‚, `f(x) = a(b(x))`çš„æ„æ€æ˜¯, å‡½æ•°fæœ‰ä¸€ä¸ªå‚æ•°, è¿™ä¸ªå‚æ•°ä¼šè¢«bè®¡ç®—, å¾—åˆ°çš„ç»“æœå†è¢«aè®¡ç®—.

è¿™æ ·æˆ‘ä»¬å°±æŠŠå‡½æ•°`a`,`b`ç»„åˆæˆäº†å‡½æ•°`f`.å¦‚æœå†™ä½œç®­å¤´å°±æ˜¯`(a <<< b)`.

è™½ç„¶`filter`å¹¶ä¸æ˜¯å•å‚å‡½æ•°, ä½†å› ä¸ºæŸ¯é‡ŒåŒ–, è¾“å…¥äº†`filterEntry`å, `filter filterEntry`å·²ç»æ˜¯å•å‚å‡½æ•°äº†.

è¿™æ ·å¤„ç†å, è¿˜å¯ä»¥å†ä½¿ç”¨ä¸€æ¬¡`point-free`å½¢å¼:

```haskell
findEntry firstName lastName = (head <<< filter filterEntry)
```

å¦å¤–, ä½ ä¹Ÿå¯ä»¥å†™:

```haskell
findEntry firstName lastName = (filter filterEntry >>> head)
```

ä¸åŒçš„ç»„åˆæ–¹å‘è€Œå·².

## æ˜¾ç¤ºæŸ¥è¯¢ç»“æœ

ç°åœ¨, æˆ‘ä»¬å¯ä»¥é€šè¿‡`findEntry`æŸ¥æ‰¾é€šè®¯å½•çš„äººäº†, ä½†å®ƒè¿”å›çš„æ˜¯ä¸€ä¸ª`Maybe Entry`.

å› ä¸ºåªæœ‰å­—ç¬¦ä¸²æ‰èƒ½è¢«æ‰“å°å‡ºæ¥, æ‰€ä»¥æˆ‘ä»¬å¾—å†™ä¸€ä¸ª`Maybe Entry`è½¬å­—ç¬¦ä¸²çš„å‡½æ•°.

```haskell
showMaybeEntry :: Maybe Entry -> String
showMaybeEntry Nothing = "Nothing"
showMaybeEntry (Just a) = "Just (" <> showEntry a <> ")"
```

ä½ å¯ä»¥çœ‹çœ‹`Maybe`ç±»å‹çš„å®šä¹‰(æŒ‰ä½`ctrl`ç‚¹å‡»`Maybe`), è¿™ä¸ªå‡½æ•°åªæ˜¯ä¸€ä¸ªç®€å•çš„æ¨¡å¼åŒ¹é…è€Œå·².

ä¹‹åæˆ‘ä»¬ä¹Ÿä¼šè®¨è®ºæ›´å¤šå†…å®¹.

## æµ‹è¯•

ç°åœ¨ä½ çš„æ–‡ä»¶å¤§æ¦‚æ˜¯è¿™æ ·:

```haskell
module Main where

import Prelude

import Data.List (List(..), head, filter)
import Data.Maybe (Maybe(..))
import Effect (Effect)
import Effect.Console (log)

type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }

type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }

type AddressBook = List Entry

showAddress :: Address -> String
showAddress addr = addr.street <> ", " <> addr.city <> ", " <> addr.state

showEntry :: Entry -> String
showEntry entry = entry.lastName <> ", " <> entry.firstName <> ": " <> (showAddress entry.address)

emptyBook :: AddressBook
emptyBook = Nil

insertEntry :: Entry -> AddressBook -> AddressBook
insertEntry = Cons

showAddressBook :: AddressBook -> String
showAddressBook Nil = ""
showAddressBook (Cons entry book) = showEntry entry <> ";" <> showAddressBook book

findEntry :: String -> String -> AddressBook -> Maybe Entry
findEntry firstName lastName book = head (filter filterEntry book)
  where
    filterEntry :: Entry -> Boolean
    filterEntry entry = entry.firstName == firstName && entry.lastName == lastName

showMaybeEntry :: Maybe Entry -> String
showMaybeEntry Nothing = "Nothing"
showMaybeEntry (Just a) = "Just (" <> showEntry a <> ")"

main :: Effect Unit
main = do
  log "ğŸ"
```

å¥½äº†, æ¥æµ‹è¯•:

```bash
> address = { street: "123 Fake St.", city: "Faketown", state: "CA" }
> entry = { firstName: "John", lastName: "Smith", address: address }
> newBook = insertEntry entry emptyBook
> findData = findEntry "John" "Smith" newBook 
> showMaybeEntry findData    
"Just (Smith, John: 123 Fake St., Faketown, CA)"
> showMaybeEntry ( findEntry "aaa" "bbb" newBook )              
"Nothing"
```

## è¿è¡Œ

å¦‚æœä¸æƒ³æŠ˜è…¾äº¤äº’æ¨¡å¼äº†, å¯ä»¥å†™åˆ°æºç é‡Œ, ç›´æ¥è¿è¡Œ:

```haskell
module Main where

import Prelude

import Data.List (List(..), head, filter)
import Data.Maybe (Maybe(..))
import Effect (Effect)
import Effect.Console (log)

type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }

type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }

type AddressBook = List Entry

showAddress :: Address -> String
showAddress addr = addr.street <> ", " <> addr.city <> ", " <> addr.state

showEntry :: Entry -> String
showEntry entry = entry.lastName <> ", " <> entry.firstName <> ": " <> (showAddress entry.address)

emptyBook :: AddressBook
emptyBook = Nil

insertEntry :: Entry -> AddressBook -> AddressBook
insertEntry = Cons

showAddressBook :: AddressBook -> String
showAddressBook Nil = ""
showAddressBook (Cons entry book) = showEntry entry <> ";" <> showAddressBook book

findEntry :: String -> String -> AddressBook -> Maybe Entry
findEntry firstName lastName book = head (filter filterEntry book)
  where
    filterEntry :: Entry -> Boolean
    filterEntry entry = entry.firstName == firstName && entry.lastName == lastName

showMaybeEntry :: Maybe Entry -> String
showMaybeEntry Nothing = "Nothing"
showMaybeEntry (Just a) = "Just (" <> showEntry a <> ")"

address :: Address
address = { street: "123 Fake St.", city: "Faketown", state: "CA" }

entryData :: Entry
entryData = { firstName: "John", lastName: "Smith", address: address }

newBook :: AddressBook
newBook = insertEntry entryData emptyBook

main :: Effect Unit
main = do
  log (showMaybeEntry (findEntry "John" "Smith" newBook))
```

ç°åœ¨ä½¿ç”¨`spago run`è¿è¡Œ:

```bash
$ spago run
[info] Build succeeded.
Just (Smith, John: 123 Fake St., Faketown, CA)
```

### ç¾å…ƒç¬¦

å› ä¸ºè¿ç®—ä¼˜å…ˆçº§çš„é—®é¢˜, `log`è¿™é‡Œçš„æ‹¬å·æ˜¯å¿…é¡»çš„.

å¦‚æœä¸åŠ æ‹¬å·, ä¾‹å¦‚è¿™æ ·: `log showMaybeEntry findEntry "John" "Smith" newBook`.

å°±ä¼šå˜æˆ, ç”¨`showMaybeEntry`å»è°ƒç”¨`log`, å¾—åˆ°çš„å€¼ä¼šæ˜¯ä¸€ä¸ªå‡½æ•°, å†ç”¨`findEntry`è°ƒç”¨è¿™ä¸ªå‡½æ•°, ç­‰ç­‰...

å¹¸è¿çš„æ˜¯, æœ‰ä¸ªç¬¦å·å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜:

```haskell
apply :: forall a b. (a -> b) -> a -> b
apply f x = f x

infixr 0 apply as $
```

æœ‰ä¸€ä¸ªå‡½æ•°, `apply`, å®ƒæ¥æ”¶ä¸¤ä¸ªå‚æ•°, ç¬¬ä¸€ä¸ªæ˜¯å‡½æ•°, ç¬¬äºŒä¸ªæ˜¯å€¼, å®ƒä»¥å€¼è°ƒç”¨å‡½æ•°. å…¶å®ä»–ä»€ä¹ˆéƒ½æ²¡åš.

ä½†é‡å®šä¹‰ä¸ºæœ€ä½ä¼˜å…ˆçº§å, å°±å‡ºç°äº†ç¥å¥‡çš„æ•ˆæœ.

```haskell
  log $ showMaybeEntry (findEntry "John" "Smith" newBook)
```

å› ä¸º`$`çš„ä¼˜å…ˆçº§æœ€ä½, æ‰€ä»¥å®ƒå·¦è¾¹çš„å½’å·¦è¾¹, å³è¾¹çš„å½’å³è¾¹, åªæœ‰å·¦å³éƒ½å®Œæˆå, æ‰ä¼šç”¨å·¦è°ƒç”¨å³.

è¿™æ•ˆæœ, ç­‰ä»·äºæŠŠå³è¾¹çš„æ‰€æœ‰å†…å®¹åŠ ä¸ªæ‹¬å·.

å¯ä»¥è¿›ä¸€æ­¥ç®€åŒ–:

```haskell
  log $ showMaybeEntry $ findEntry "John" "Smith" newBook
```

æ¼‚äº®å¤šäº†.