# 实例-通讯录-下

## 创建空通讯录

我们先创建一个数据, 作为空的通讯录, 并且说明它的类型是`AddressBook`:

```haskell
emptyBook :: AddressBook
emptyBook = Nil
```

现在`Nil`还不能使用,需要在引入的时候,说明要引入`List`的`Nil`构造子.

```haskell
import Data.List (List(Nil))
```

如果还想引入`Cons`构造子, 可以

```haskell
import Data.List (List(Nil, Cons))
```

如果要引入全部构造子, 可以

```haskell
import Data.List (List(..))
```

现在你的文件大概长这样:

```haskell
module Main where

import Prelude
import Effect (Effect)
import Effect.Console (log)
import Data.List (List(..))

type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }

type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }

type AddressBook = List Entry

showEntry :: Entry -> String
showEntry entry = entry.lastName <> ", " <> entry.firstName <> ": " <> showAddress entry.address

showAddress :: Address -> String
showAddress addr = addr.street <> ", " <> addr.city <> ", " <> addr.state

emptyBook :: AddressBook
emptyBook = Nil

main :: Effect Unit
main = do
  log "🍝"
```

## 插入

现在我们写一个函数, 它接受一个通讯录条目(`Entry`)和一个通讯录(`AddressBook`), 返回另一个通讯录(`AddressBook`).

```haskell
insertEntry :: Entry -> AddressBook -> AddressBook
insertEntry entry book = Cons entry book
```

当然你也可以把他写成`point-free`形式,可以分别把`book`和`entry`都约掉:

```haskell
insertEntry :: Entry -> AddressBook -> AddressBook
insertEntry = Cons
```

除此以外, 我们还需要有一个把通讯录转换成字符串的函数.

```haskell
showAddressBook :: AddressBook -> String
showAddressBook Nil = ""
showAddressBook (Cons entry book) = showEntry entry <> ";" <> showAddressBook book
```

现在你的文件大概是这样:

```haskell
module Main where

import Prelude
import Effect (Effect)
import Effect.Console (log)
import Data.List (List(..))

type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }

type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }

type AddressBook = List Entry

showAddress :: Address -> String
showAddress addr = addr.street <> ", " <> addr.city <> ", " <> addr.state

showEntry :: Entry -> String
showEntry entry = entry.lastName <> ", " <> entry.firstName <> ": " <> (showAddress entry.address)

emptyBook :: AddressBook
emptyBook = Nil

insertEntry :: Entry -> AddressBook -> AddressBook
insertEntry = Cons

showAddressBook :: AddressBook -> String
showAddressBook Nil = ""
showAddressBook (Cons entry book) = showEntry entry <> ";" <> showAddressBook book

main :: Effect Unit
main = do
  log "🍝"
```

试试:

```bash
> address = { street: "123 Fake St.", city: "Faketown", state: "CA" }
> entry = { firstName: "John", lastName: "Smith", address: address }
> showAddressBook (insertEntry entry emptyBook)                      
"Smith, John: 123 Fake St., Faketown, CA;"
```

## 查询

我们写一个函数,输入姓名,查出地址:

```haskell
findEntry :: String -> String -> AddressBook -> Maybe Entry
findEntry firstName lastName book = head (filter filterEntry book)
  where
    filterEntry :: Entry -> Boolean
    filterEntry entry = entry.firstName == firstName && entry.lastName == lastName
```

我们看到了几个新东西, 首先是`head`和`filter`.这是两个`List`的处理函数,也定义在`Data.List`模块.

要引入它们的话, 你应该把引入的部分改成:

```haskell
import Data.List (List(..), head, filter)
```

其中`head`是取`List`的第一个元素, `filter`接受两个参数, 第一个参数是一个函数, 第二个参数是一个`List`. 就像他的名字所说, 用函数过滤`List`.

按住`ctrl`, 点击函数, 就可以看到它的签名和实现.

接下来是`Maybe`, 这是一个类型, 就像`List`一样, 它也是一个泛型类型. 按住`ctrl`, 点击它, 也可以看到它的源码.

不只是类型和函数, 任何符号几乎都对应着源码的实现, 看源码是主要的学习方法, 通常这些源码都非常简短, 还带有注释, 不难看懂.

之后我们会去读这些源码, 这里我们把注意力放在`findEntry`函数上.

先看签名,输入姓,名,通讯录,然后返回一个`Maybe Entry`.

看实现, 按`filterEntry`将输入的通讯录过滤, 并取它的第一个项.

而`filterEntry`定义在`where`里:输入一个通讯录项, 判断姓名是否符合我们传入的姓名, 符合返回真, 不符合返回假.

这样自然就找到了匹配姓名的那个条目.

### 函数组合

另外

可以用另一种写法:

```haskell
findEntry firstName lastName book = (head <<< filter filterEntry) book
```

这个`<<<`符号是函数组合, 对于两个单参数函数, 是可以组合的.

例如, `f(x) = a(b(x))`的意思是, 函数f有一个参数, 这个参数会被b计算, 得到的结果再被a计算.

这样我们就把函数`a`,`b`组合成了函数`f`.如果写作箭头就是`(a <<< b)`.

虽然`filter`并不是单参函数, 但因为柯里化, 输入了`filterEntry`后, `filter filterEntry`已经是单参函数了.

这样处理后, 还可以再使用一次`point-free`形式:

```haskell
findEntry firstName lastName = (head <<< filter filterEntry)
```

另外, 你也可以写:

```haskell
findEntry firstName lastName = (filter filterEntry >>> head)
```

不同的组合方向而已.

## 显示查询结果

现在, 我们可以通过`findEntry`查找通讯录的人了, 但它返回的是一个`Maybe Entry`.

因为只有字符串才能被打印出来, 所以我们得写一个`Maybe Entry`转字符串的函数.

```haskell
showMaybeEntry :: Maybe Entry -> String
showMaybeEntry Nothing = "Nothing"
showMaybeEntry (Just a) = "Just (" <> showEntry a <> ")"
```

你可以看看`Maybe`类型的定义(按住`ctrl`点击`Maybe`), 这个函数只是一个简单的模式匹配而已.

之后我们也会讨论更多内容.

## 测试

现在你的文件大概是这样:

```haskell
module Main where

import Prelude

import Data.List (List(..), head, filter)
import Data.Maybe (Maybe(..))
import Effect (Effect)
import Effect.Console (log)

type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }

type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }

type AddressBook = List Entry

showAddress :: Address -> String
showAddress addr = addr.street <> ", " <> addr.city <> ", " <> addr.state

showEntry :: Entry -> String
showEntry entry = entry.lastName <> ", " <> entry.firstName <> ": " <> (showAddress entry.address)

emptyBook :: AddressBook
emptyBook = Nil

insertEntry :: Entry -> AddressBook -> AddressBook
insertEntry = Cons

showAddressBook :: AddressBook -> String
showAddressBook Nil = ""
showAddressBook (Cons entry book) = showEntry entry <> ";" <> showAddressBook book

findEntry :: String -> String -> AddressBook -> Maybe Entry
findEntry firstName lastName book = head (filter filterEntry book)
  where
    filterEntry :: Entry -> Boolean
    filterEntry entry = entry.firstName == firstName && entry.lastName == lastName

showMaybeEntry :: Maybe Entry -> String
showMaybeEntry Nothing = "Nothing"
showMaybeEntry (Just a) = "Just (" <> showEntry a <> ")"

main :: Effect Unit
main = do
  log "🍝"
```

好了, 来测试:

```bash
> address = { street: "123 Fake St.", city: "Faketown", state: "CA" }
> entry = { firstName: "John", lastName: "Smith", address: address }
> newBook = insertEntry entry emptyBook
> findData = findEntry "John" "Smith" newBook 
> showMaybeEntry findData    
"Just (Smith, John: 123 Fake St., Faketown, CA)"
> showMaybeEntry ( findEntry "aaa" "bbb" newBook )              
"Nothing"
```

## 运行

如果不想折腾交互模式了, 可以写到源码里, 直接运行:

```haskell
module Main where

import Prelude

import Data.List (List(..), head, filter)
import Data.Maybe (Maybe(..))
import Effect (Effect)
import Effect.Console (log)

type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }

type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }

type AddressBook = List Entry

showAddress :: Address -> String
showAddress addr = addr.street <> ", " <> addr.city <> ", " <> addr.state

showEntry :: Entry -> String
showEntry entry = entry.lastName <> ", " <> entry.firstName <> ": " <> (showAddress entry.address)

emptyBook :: AddressBook
emptyBook = Nil

insertEntry :: Entry -> AddressBook -> AddressBook
insertEntry = Cons

showAddressBook :: AddressBook -> String
showAddressBook Nil = ""
showAddressBook (Cons entry book) = showEntry entry <> ";" <> showAddressBook book

findEntry :: String -> String -> AddressBook -> Maybe Entry
findEntry firstName lastName book = head (filter filterEntry book)
  where
    filterEntry :: Entry -> Boolean
    filterEntry entry = entry.firstName == firstName && entry.lastName == lastName

showMaybeEntry :: Maybe Entry -> String
showMaybeEntry Nothing = "Nothing"
showMaybeEntry (Just a) = "Just (" <> showEntry a <> ")"

address :: Address
address = { street: "123 Fake St.", city: "Faketown", state: "CA" }

entryData :: Entry
entryData = { firstName: "John", lastName: "Smith", address: address }

newBook :: AddressBook
newBook = insertEntry entryData emptyBook

main :: Effect Unit
main = do
  log (showMaybeEntry (findEntry "John" "Smith" newBook))
```

现在使用`spago run`运行:

```bash
$ spago run
[info] Build succeeded.
Just (Smith, John: 123 Fake St., Faketown, CA)
```

### 美元符

因为运算优先级的问题, `log`这里的括号是必须的.

如果不加括号, 例如这样: `log showMaybeEntry findEntry "John" "Smith" newBook`.

就会变成, 用`showMaybeEntry`去调用`log`, 得到的值会是一个函数, 再用`findEntry`调用这个函数, 等等...

幸运的是, 有个符号可以解决这个问题:

```haskell
apply :: forall a b. (a -> b) -> a -> b
apply f x = f x

infixr 0 apply as $
```

有一个函数, `apply`, 它接收两个参数, 第一个是函数, 第二个是值, 它以值调用函数. 其实他什么都没做.

但重定义为最低优先级后, 就出现了神奇的效果.

```haskell
  log $ showMaybeEntry (findEntry "John" "Smith" newBook)
```

因为`$`的优先级最低, 所以它左边的归左边, 右边的归右边, 只有左右都完成后, 才会用左调用右.

这效果, 等价于把右边的所有内容加个括号.

可以进一步简化:

```haskell
  log $ showMaybeEntry $ findEntry "John" "Smith" newBook
```

漂亮多了.