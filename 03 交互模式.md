# 交互模式

输入下面的命令进入交互模式

```shell
$ spago repl
```

## 简单使用

```bash
# 你可以使用`:type <值>`来查看某个值的类型
# 基础类型
> :type 1
Int

> :type 1.0
Number

> :type "test"
String

> :type true
Boolean

> :type 'a'
Char

# 数组
# 请注意 `Array Int` 是一个类型, 虽然中间有空格, 但他是一个类型.
> :type [1, 2, 3]
Array Int

> :type [true, false]
Array Boolean

# 数组不可以容纳不同类型的值
> :type [1, false]
Could not match type Int with type Boolean.

# 你可以这样定义一个变量 这定义了一个记录值
> author = { name: "Phil", interests: ["Functional Programming", "JavaScript"] }

# 记录值的类型
> :type author
{ name :: String
, interests :: Array String
}

# 可以使用点来访问记录内部
> author.name
"Phil"

> author.interests
["Functional Programming","JavaScript"]

# 函数也有类型
> :type flip
forall a b c. (a -> b -> c) -> b -> a -> c

> :type const
forall a b. a -> b -> a

# 可以这样定义函数
# 函数的语法会在之后讨论
> add x y = x + y

# 看一下类型
> :t add
forall (t3 :: Type). Semiring t3 => t3 -> t3 -> t3

# 调用
> add 1 2
3

# 甚至可以不全调用
# 函数可以不全调用的特性, 称为函数的`柯里化`
> f = add 1

# 不全调用的函数的类型
> :t f
Int -> Int

# 继续调用
> f 2
3
```

## 混合使用

在`Main.purs`中写一个函数(具体语法会在之后讨论):

```haskell
add :: Int -> Int -> Int
add a b = a + b
```

你的`Main.purs`看起来像是这样:

```haskell
module Main where

import Prelude

import Effect (Effect)
import Effect.Console (log)

fun :: Int -> Int -> Int
fun a b = a + b

main :: Effect Unit
main = do
  log "🍝"
```

接下来进入交互模式,引入这个模块:

```bash
> import Main
```

这样,就可以使用文件中定义的东西啦.

```bash
# 函数 fun 的类型, 输入一个 Int 后, 返回一个 Int -> Int 的函数
> :t fun     
Int -> Int -> Int

# 就像上面说的, 输入了一个 Int 的值后, 返回了一个 Int -> Int 的函数
> :t (fun 1)
Int -> Int

# 自然, 给 Int -> Int 的函数再输入一个 Int 值的话, 会得到 Int
> :t (fun 1 2)
Int

> fun 1 2
3
```

这里只写了一个函数, 其实类型也可以.

你可以用交互模式来做一些简单的测试.

注意,修改代码后,需要重新编译和引入才能生效. 或使用命令`:reload`.
