# 与js互操作

## js调用PureScript

### 编译为模块

```
spago build
```

- 会编译模块和依赖模块,都在out文件夹里.
- 他们会互相引用,如果要用,可以把out文件夹整个拷走.

### 打包为可执行程序

```
spago bundle-app
```

- 会生成一个叫`index.js`的文件
- 可以直接运行
- 会自动处理依赖关系

###  打包为模块

```
spago bundle-module
```

- 会生成一个叫`index.js`的文件
- 会导出Main模块指定的内容
- 是使用`commonJS`规范导出的
- 会自动处理依赖关系

## PureScript调用js

### 快速开始

首先新建一个purs文件,写:

```haskell
module Test.URI where

foreign import encodeURIComponent :: String -> String
```

然后新建一个同名js文件:

```JavaScript
exports.encodeURIComponent = encodeURIComponent
```

接下来就可以使用这个函数了:

```haskell
$ spago repl

> import Test.URI
> encodeURIComponent "Hello World"
"Hello%20World"
```

### 柯里化

需要注意的是, 在js里编写的函数应该是柯里化的.

例如计算两个数相加的函数应该写成`a=>b=>a+b`而不是`(a,b)=>a+b`.

不过你也可以这样包装`(a,b)=>a+b`形式的函数:

```haskell
foreign import diagonalUncurried :: Fn2 Number Number Number
```

运行的时候也要包装

```haskell
> runFn2 diagonalUncurried 3.0 4.0
5.0
```

### 高级类型

对于字符串,数字,布尔类型, js和purs里都有, 他们会等价转换, js返回的数字就等于purs里的数字.

对于数组和对象, 也会等价转换:

数组:

```haskell
foreign import fun1 :: Unit -> Array Int
```

```javascript
exports.fun1 = function () {
    return [1, 2, 3]
}
```

```haskell
> fun1 unit      
[1,2,3]
```

对象:

```haskell
foreign import fun2 :: Unit -> { a::Int, b::String }
```

```javascript
exports.fun2 = function () {
    return { a: 1, b: '2' }
}
```

```haskell
> fun2 unit
{ a: 1, b: "2" }
```

注意, 编译器并不会检查你js是否返回了约定的格式, 需要程序员自己注意.

### ADT类型

如果你想用js返回一个Maybe怎么办?

推荐的方法是, 将构造子传进去, 比如自己实现一个head:

```haskell
foreign import maybeHeadImpl :: forall a. (forall x. x -> Maybe x) -> (forall x. Maybe x) -> Array a -> Maybe a
maybeHead :: forall a. Array a -> Maybe a
maybeHead arr = maybeHeadImpl Just Nothing arr
```

```javascript
exports.maybeHeadImpl = just => nothing => arr => {
  if (arr.length) {
    return just(arr[0]);
  } else {
    return nothing;
  }
}
```

### 外部类型

我们可以这样定义一个外部类型

```haskell
foreign import data Undefined :: Type -> Type
```

但是我们不能实现它, 它只是作为一个类型.

我们可以在其他的地方使用它:

```haskell
foreign import undefinedHead :: forall a. Array a -> Undefined a
```

```javascript
exports.undefinedHead = arr => arr[0]
```

这样我们就获得一个返回Undefined类型的函数了, 但Undefined类型是什么, 我们无法处理它.

但没关系, 我们可以再次依赖外部函数实现:

```haskell
foreign import isUndefined :: forall a. Undefined a -> Boolean
```

```javascript
exports.isUndefined = value => value === undefined
```

最后把他们结合在一起:

```haskell
isEmpty :: forall a. Array a -> Boolean
isEmpty = isUndefined <<< undefinedHead
```

### 异常

如果js函数抛出异常会怎样?

就像之前fs读文件一样, 会抛出异常, 你可以用try把他转换成Either.

### 副作用

一个用js实现打印到控制台函数的例子:

```haskell
foreign import my_print_impl :: forall a. (a -> String) -> a -> Effect Unit

my_print :: forall a. Show a => a -> Effect Unit
my_print = my_print_impl show
```

```javascript
exports.my_show_impl = show => x => () => console.log(show(x))
```

```haskell
module Main where

import Prelude

import Effect (Effect)
import Effect.Console (log)
import Test (my_print)

main :: Effect Unit
main = my_print 1
```

### Promise

js中的Promise可以通过库[purescript-aff](https://pursuit.purescript.org/packages/purescript-aff-promise/2.0.1)转换成AFF.

### JSON验证

这个库[purescript-argonaut](https://pursuit.purescript.org/packages/purescript-argonaut/8.0.0),可以对js返回的json进行验证,结果会被包装为Either,这里做一个简单的例子:

```haskell
module Test where

import Prelude

import Data.Argonaut.Core (Json)
import Data.Argonaut.Decode (JsonDecodeError, decodeJson)
import Data.Either (Either)

foreign import fun1 :: Unit -> Json

fun2 :: Either JsonDecodeError { a:: Int, b:: String }
fun2 = decodeJson $ fun1 unit
```

```javascript
exports.fun1 = function () {
    return {
        a: 1,
        b: '2'
    }
}
```

```haskell
module Main where

import Prelude

import Effect (Effect)
import Effect.Console (log)
import Test (fun2)

main :: Effect Unit
main = do
    log $ show $ fun2
```

格式正确时:

```haskell
(Right { a: 1, b: "2" })
```

如果修改js的返回值:

```javascript
exports.fun1 = function () {
    return {
        a: 1,
        b: 2
    }
}
```

得到:

```haskell
(Left (AtKey "b" (TypeMismatch "String")))
```

