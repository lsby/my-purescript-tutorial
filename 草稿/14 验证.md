# 验证

本章讲解一个常见的模式,数据验证,及其实现.

## Maybe

### 单参数

Maybe适用于"数据可能不存在"的情况,比如,我们要从数据库中读一个数据回来,然后对它进行二次处理.

但数据库读取可能失败,所以读数据库的函数应该返回Maybe String,而不是String.

假如我们读回来了一个名字,现在要对它问好.

我们先写出问好函数:

```haskell
fun1 :: String -> String
fun1 a = "hello, " <> a
```

但问题是这个函数输入的是String,而不是Maybe String.但没关系,因为Maybe实现了函子类型类,所以我们可以用map提示fun,让它能用在Maybe上.

```haskell
> map fun1 Nothing  
Nothing

> map fun1 (Just "abc")
(Just "hello, abc")
```

### 多参数

如果是多参数函数呢?如果我们有两个Maybe数据,嗯..比如把他连起来成一个字符串.

首先先是连起来成字符串的函数

```haskell
fun2 :: String -> String -> String
fun2 a b = a <> b
```

因为Maybe也实现了应用函子, 所以就像上面说的,提升多参数函数,用lift:

```haskell
> lift2 fun2 (Just "a") (Just "b")
(Just "ab")

> lift2 fun2 (Just "a") (Nothing) 
Nothing

> lift2 fun2 (Nothing) (Just "b") 
Nothing
```

当然也可以用`<$>`和`<*>`的形式:

```haskell
> fun2 <$> (Just "a") <*> (Just "b")
(Just "ab")
```

## Either

看起来很好,如果输入的任何一个是Nothing,得到的就会是Nothing.

但如果我想要程序精确的提示哪个参数不存在,怎么办?

有一个数据类型是Either,它有两个构造子,Left和Right.

```haskell
data Either a b = Left a | Right b
```

这个类型表示"两种类型的值间做选择"的模式.

它的map实现很有意思, 如果值是用Left构造的, 将不会计算, 永远保持不变, 而如果值是Right构造的, 就会计算.

```haskell
f <$> Right x == Right (f x)
f <$> Left y == Left y
```

它也实现了应用函子,也是一样,左值不变,右值计算:

```haskell
Right f <*> Right x == Right (f x)
Left f <*> Right x == Left f
Right f <*> Left y == Left y
```

所以很容易用它做错误提示,只需要检查一下输入的Maybe是不是Nothing,如果是,就建一个Left,反正它怎么算都不会变,最后一定得到的还是它.

写一个转换函数:

```haskell
genErr :: forall a. Maybe a -> String -> Either String a
genErr (Nothing) tip = Left tip
genErr (Just a) _ = Right a
```

输入一个Maybe值,和一个提示字符串,如果Maybe值是Nothing,用左值包装tip,否则用右值包装Maybe的值.

```haskell
> map fun1 (genErr Nothing "err tip")     
(Left "err tip")

> map fun1 (genErr (Just "abc") "err tip")
(Right "hello, abc")
```

```haskell
> lift2 fun2 (genErr (Just "abc") "err tip1") (genErr (Just "def") "err tip2")
(Right "abcdef")

> lift2 fun2 (genErr (Just "abc") "err tip1") (genErr Nothing "err tip2")     
(Left "err tip2")

> lift2 fun2 (genErr Nothing "err tip1") (genErr (Just "def") "err tip2")     
(Left "err tip1")

> lift2 fun2 (genErr Nothing "err tip1") (genErr Nothing "err tip2")     
(Left "err tip1")
```

需要注意的是如果两个值都是Nothing, 只会返回第一个报错, 毕竟出现第一个报错后, 他就不会再变了.

如果想一次获得所有错误,之后我们会讨论.

## V

接着上面的例子,如何一次获得全部错误呢?

想想也很简单,只要改改Left的行为,把他从"什么都不做"改成"累积结果"就可以了,不过有另一个数据已经帮我们实现了.

https://pursuit.purescript.org/packages/purescript-validation/5.0.0/docs/Data.Validation.Semigroup#t:V

它有很多用法,看看下面的函数就知道,不过我们用最简单的,看看它的构造子:

```haskell
newtype V err result = V (Either err result)
```

之前讲过newtype基本等于高性能版的data.也就是说V这个类型有一个同名的构造子, 这个构造子需要传入一个`Either err result`的值.

而`err`和`result`是泛型.

改造一下刚才的转换函数:

```haskell
genErr :: forall a. Maybe a -> String -> V String a
genErr (Nothing) tip = V (Left tip)
genErr (Just a) _ = V (Right a)
```

试试:

```haskell
> lift2 fun2 (genErr Nothing "err tip1") (genErr Nothing "err tip2")     
invalid ("err tip1err tip2")
```

看起来不是很好, 两个错误混在一起了, 事实上, 只要返回任意一个符合半群的类型都行,我们用数组试试:

```haskell
genErr :: forall a. Maybe a -> String -> V (Array String) a
genErr (Nothing) tip = V (Left [tip])
genErr (Just a) _ = V (Right a)
```

```haskell
> lift2 fun2 (genErr Nothing "err tip1") (genErr Nothing "err tip2")     
invalid (["err tip1","err tip2"])
```

非常完美!

## 正则验证

现在我们仅仅是验证数据是不是Nothing,如果我们要验证它的形式呢?

这里有一个正则类型

https://pursuit.purescript.org/packages/purescript-strings/5.0.0/docs/Data.String.Regex#t:Regex

看看如何使用,首先可以找到一个叫`test`的方法.

```haskell
-- | Returns `true` if the `Regex` matches the string. In contrast to
-- | `RegExp.prototype.test()` in JavaScript, `test` does not affect
-- | the `lastIndex` property of the Regex.
foreign import test :: Regex -> String -> Boolean
```

就是我们要找的测试函数了,那么`Regex`类型的数据哪来呢?

找到了这个:

```haskell
-- | Constructs a `Regex` from a pattern string and flags. Fails with
-- | `Left error` if the pattern contains a syntax error.
regex :: String -> RegexFlags -> Either String Regex
```

那么还缺一个`RegexFlags`的构造方法,找到这个:

```haskell
-- | Parses the string representation of `RegexFlags`.
parseFlags :: String -> RegexFlags
```

齐了,先来试试:

```haskell
> map (\a->test a "aaaa") (regex "aaa" (parseFlags "g"))
(Right true)

> map (\a->test a "123") (regex "aaa" (parseFlags "g")) 
(Right false)
```

那么现在试试用在fun2上, 比如我需要fun2的第一个参数是数字, 第二个参数是字母. 对应的正则是"^[0-9]\*$"和"^[a-zA-Z]\*$".

用多种花样写了差不多的东西...

```haskell
isNumber :: Maybe String -> String -> V (Array String) String
isNumber (Nothing) tip = V (Left [tip])
isNumber (Just a) tip = case regObj of
    (Left s) -> V (Left [s])
    (Right reg) -> case test reg a of
      true -> V (Right a)
      false -> V (Left [tip])
    where
      regObj :: Either String Regex
      regObj = regex "^[0-9]*$" (parseFlags "g")

isLetter :: Maybe String -> String -> V (Array String) String
isLetter (Nothing) tip = V (Left [tip])
isLetter (Just a) tip = case lift2 test regObj (Right a) of
  (Left e) -> V (Left [tip])
  (Right true) -> V (Right a)
  (Right false) -> V (Left [tip])
  where
    regObj :: Either String Regex
    regObj = regex "^[a-zA-Z]*$" (parseFlags "g")
```

试试:

```haskell
> isNumber (Nothing) "err"
invalid (["err"])

> isNumber (Just "aaa") "err"
invalid (["err"])

> isNumber (Just "123") "err"
pure ("123")

> isLetter (Nothing) "err"   
invalid (["err"])

> isLetter (Just "aaa") "err"
pure ("aaa")

> isLetter (Just "123") "err"
invalid (["err"])
```

```haskell
> lift2 fun2 (isNumber (Just "1") "err1") (isLetter (Just "a") "err2")
pure ("1a")

> lift2 fun2 (isNumber (Just "1") "err1") (isLetter (Just "1") "err2")
invalid (["err2"])

> lift2 fun2 (isNumber (Just "a") "err1") (isLetter (Just "a") "err2")
invalid (["err1"])

> lift2 fun2 (isNumber (Just "a") "err1") (isLetter (Just "1") "err2")
invalid (["err1","err2"])
```

## 遍历

Traversable是一个类型类.

https://pursuit.purescript.org/packages/purescript-foldable-traversable/5.0.1/docs/Data.Traversable#t:Traversable

```haskell
class (Functor t, Foldable t) <= Traversable t where
  traverse :: forall a b m. Applicative m => (a -> m b) -> t a -> m (t b)
  sequence :: forall a m. Applicative m => t (m a) -> m (t a)
```

### 副作用和效果

Maybe a是什么意思?

按照最本质的想法,这意味着一个Maybe类型的值,其中a是Maybe的泛型参数.

但结合类型是模型的想法,我们有另一个说法:这是一个`a`类型的值,它被包裹在一个`Maybe`的`上下文`里.

有时候我们把`上下文`也叫做`效果`.

Maybe是"可能不存在"的效果,List是"多重可能性"的效果,IO是"需要IO操作才可以计算"的效果.

副作用只是效果的一种.

### 效果和类型类

Maybe是"可能不存在"的效果,那么这个效果能进行怎样的操作呢?

比如,我能否用一个函数操作这个"可能不存在"的值呢?那只要看Maybe是否实现了函子类型类就可以了.

Applicative则意味着"可以将若干个同类型的值合成一个", 就是如果我有很多个Maybe类型的值,我是否能把他们合成一个Maybe类型的值.

Monad则意味着,在合成的时候,能否参考上一次的结果.(?)

之后我们会说到.

### sequence

想象这样一个场景:你有一个List (IO a),这可以理解为,一个list的每一项都是一个需要IO操作才可以获得的数据,这个数据是a类型的.

如果把这些IO操作都计算了,我们可以得到List a.

但实际上,我可能这里需要的就是List a的数据,但IO操作不执行也不行呀?但至少,我们可以把IO合成一个,然后先计算.

也就是将数据转换为IO (List a).sequence就是做这件事的.

IO能合成一个的条件是它必须实现Applicative类型类.

事实上不只是IO,任何实现Applicative类型类的类型都可以做如此的转换.

Traversable就是对这种能力的抽象.