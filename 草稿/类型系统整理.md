# 类型系统整理

## 值和类型

有一种东西, 值.

值有类型, 类.型只是一个名称.

类型又有 kind类型, kind类型的形式是type->type->type->...

## 类型组合

如果某类型A的kind类型是type->type, 那么意味着它后面可以再写另一个类型B, B的kind类型必须是type.

这样可以组成一个新的类型`A B`.

## 类型定义

常见的类型有Int, String等等, 他们的kind类型都是type.

可以定义新类型, 例如:

```haskell
data MyType1 = MyType1_C String
```

这定义了一个名叫MyType1的类型, 它的kind类型是type.

而MyType1_C是构造子, 通过它来创建一个MyType1类型的值.

如果加入泛型:

```haskell
data MyType2 a = MyType2_C a
```

这定义了一个名叫MyType2的类型, 它的kind类型是type->type.

MyType2_C是构造子, 用它来创建MyType2类型的值.

## 值别名

可以定义某个符号来表示某个值, 例如:

```haskell
aaa :: Int
aaa = 1
```

这里第一行说明aaa是一个Int类型的值的别名.

第二行说明aaa是1的别名.

对于kind类型高的类型也是一样:

```haskell
data MyType2 a = MyType2_C a

aaa :: MyType2 String
aaa = MyType2_C "hello"
```

不可以直接定义`aaa :: MyType2`, 符号的类型的kind类型一定是type.

## 函数值别名

特别的, 有一个类型Function.

这个类型是系统内置的, 它的kind类型是type->type->type.

但它没有直接可使用的构造子.

要创建它, 用语法糖:

```haskell
aaa :: Function Int Int
aaa a = a + 1
```

这就是我们熟悉的函数定义.

这和上面的一样的, aaa是一个值, 它的类型是`Function Int Int`, 唯一的不同是我们不是用Function的构造子定义它的.

另外函数还带来了类型间的转换, aaa的定义意味着, `aaa <某个Int值>`这个符号会成为`<这个Int值> + a`的别名.

## 抽象别名

除此以外还可以定义抽象的符号, 这种符号符号和类型的关系更松散.

定义符号时不写出具体的类型, 只写一个字母表示类型.

例如, 我可以定义符号`aaa`, 并说明`aaa`是`t`类型的值. 这个定义的名字叫`AAA`:

```haskell
class AAA t where
  aaa : t
```

接下来, 可以用类型和符号建立关系, 例如, 建立Int和aaa的关系, 使aaa这个符号表示0:

```haskell
instance AAA Int where
  aaa = 0
```

同时, 也可以用其他类型和这个符号建立关系, 比如建立String和aaa的关系, 使aaa这个符号表示空字符串:

```haskell
instance AAA String where
  aaa = ""
```

那么aaa这个符号在不同的地方会表示不同的值, 会按类型推理.

例如, 如果某个地方需要Int值, 而你在这里地方写aaa符号, 那么它会被翻译为0.

当然, 除了定义简单的别名, 还可以定义函数.

```haskell
class AAA t where
  aaa :: Function t t

instance xxx :: AAA Int where
  aaa a = a + 1
```

这样, 当某个地方需要Int值, 而你在这里填了`aaa <某个Int值>`时, `aaa <某个Int值>`会被翻译成`<这个Int值> + 1`.
