# 类型模型

## Maybe

我们来正式介绍一下Maybe类型.

```haskell
-- | The `Maybe` type is used to represent optional values and can be seen as
-- | something like a type-safe `null`, where `Nothing` is `null` and `Just x`
-- | is the non-null value `x`.
data Maybe a = Nothing | Just a
```

翻译:

```
`Maybe`类型用于表示可选值，类似于类型安全的`null`，其中`Nothing`为`null`，`Just x`为非空值`x`。
```

它实现了Functor类型类:

```haskell
instance functorMaybe :: Functor Maybe where
  map fn (Just x) = Just (fn x)
  map _  _        = Nothing
```

## 类型模型

那么,如果一个值是Maybe Int类型的,意味着什么?

可以从不同的角度考察这个问题,但这里我们的答案是,这是一个Int类型的值,只是它在Maybe的上下文中.(或者在Maybe的"效果(effect)"中).

Maybe的效果是,某个值可能存在,也可能不存在.

如果一个值是Maybe Int类型,那么意味着这是一个"可能不存在"的Int类型的值.

是的, 不要把Maybe Int看作是Maybe类型的Int泛型,而是看作一个特别的Int类型,在有些时候这样的观点非常有帮助.

## 函数提升

既然它是如此特殊的一个值,自然无法用普通的函数进行计算:如果我们有一个Int->Int的函数,是无法用Maybe Int的值调用它的.

而类型类是一种"描述能力的接口",Functor类型类描述的是"在上下文中操作这个值的能力".

幸运的是,Maybe实现了Functor类型类,这意味着我们可以用Int->Int的函数操作这个"可能不存在的Int值"了,只要提升一下函数就可以.

那要如何操作?这就看Maybe类型对Functor类型类的具体实现了.Maybe的想法是,如果有值,就拿函数计算,如果没有值,就不计算直接返回Nothing.

接下来我们还会看到很多类型和类型类,但理解是一样的,类型是一种上下文,而类型类描述实现它的类型可以做什么,而具体的行为在类型中实现.

## List

另一个例子是List类型, 比如, 如果一个值是List Int类型, 意味着什么?

一个观点是, 意味着一个"多重可能性"的值.比如,我们有一个函数add1:

```haskell
add1 :: Int -> Int
add1 a = a + 1
```

现在我们拿一个数字调用它,比如1吧,那么我们会得到2.

那么如果是一个"多重可能性的值"呢?比如一个值,它可能是1,也有可能是2,也有可能是3.这就是List.

显然,我们的add1无法处理这种情况,但List实现了Functor类型类,这意味着我们拥有"在上下文中操作这个值的能力".

那么用提升过的add1操作"可能是1,也有可能是2,也有可能是3"的值,会得到什么呢?

会得到另一个多重可能性是值,它可能是2,可能是3,也可能是4.在List的角度来看,倒也合理.

## Applicative

Apply和Applicative是另外两个类型类,其中要实现Applicative必须要先实现Apply.为了方便,这里我们只讨论Applicative.

Applicative表示的是"合并多个效果的能力".

简单的说, Applicative要求在Functor的基础上再实现两个函数, apply和pure.

```haskell
apply :: forall a b. f (a -> b) -> f a -> f b
pure :: forall a. a -> f a
```

pure意味着可以将任何类型的值放入给定的上下文中,只要这个上下文实现了Applicative类型类.

### lift

再看看apply,考虑它的签名:

```haskell
apply :: f (a -> b) -> f a -> f b
```

如果令其中的b等于c->d,则可以写成:

```haskell
apply :: f (a -> c -> d) -> f a -> f (c -> d)
```

意味着, 使用`f (a -> c -> d)`和一个`f a`的值调用apply, 会得到一个`f (c -> d)`的值.

而如果对`f (c -> d)`的值和一个`f c`的值调用apply,套用开始的公式,将其中的a改成c,b改成d,会得到f d类型的值:

```haskell
apply :: f (c -> d) -> f c -> f d
```

那么不难想象, 可以构造一个函数, 输入一个`f (a -> c -> d)`, 然后连续调用两次`apply`, 它的签名是:

```haskell
??? :: f (a -> c -> d) -> f a -> f c -> f d
```

问题是, `f (a -> c -> d)`哪里去搞?直观的看,因为我们有pure,所以我们可以很轻松的把`a -> c -> d`变成`f (a -> c -> d)`.

实际上,我们通常不用pure,而是用map结合函数的不全调用,不过这里为了简单就不讨论过多细节了.

于是有这样的函数:

```haskell
lift2 :: forall a b c f. Apply f => (a -> b -> c) -> f a -> f b -> f c
```

与此类似,我们还有lift3,lift4,lift5,...,甚至可以做出任意参数的函数的提升.

### 合并上下文

从这个签名可以解读出另一个意思:对于任何实现Apply类型类的类型f而言,可以将f a和f b的数据合成为f c的数据.

也就是说, 将两个上下文相同的值通过某种给定的方法进行合并, 得到一个相同上下文的值. 也就是上下文的合并. 

拿Maybe来说, 意味着只要给出合适的函数, 就可以将两个Maybe上下文的值合并为另一个Maybe上下文的值.

这并不是看起来那么简单, 如果map规定了一个带有上下文的值如何被函数操作的话,apply就是规定多个上下文的值如何被函数操作了.

Maybe对此的答案是:如果两个值中任何一个是Nothing,就会得到Nothing.想想也合理.

而List对此的答案是:做笛卡尔积后拉平.

```haskell
> lift2 (\a b -> a + b) (1:2:3:Nil) (4:5:6:Nil) 
(5 : 6 : 7 : 6 : 7 : 8 : 7 : 8 : 9 : Nil)
```

确实也合理,x可能是1,2,3中的任何一个,y可能是4,5,6中的任何一个,现在问x+y的所有可能,不就是这个答案吗.

请注意,合并上下文意味着我们得到的结果中包含了(参考了)被合并的两个上下文的情况.

考虑一个更明显的例子,有一个类型是`IO`,一个`IO Int`类型的数据, 意味着, 一个Int类型的值, 但要获取它, 必须要经过一个IO操作.

那么,`apply (Int->String->Boolean) (IO Int) (IO String)`意味着什么?

合理的实现是, 你会得到一个`IO Boolean`类型的值, 当实际获取这个Boolean值时, 会按顺序执行合并前的两个IO操作.



