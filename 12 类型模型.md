# 类型模型

## Maybe

我们来正式介绍一下Maybe类型.

```haskell
-- | The `Maybe` type is used to represent optional values and can be seen as
-- | something like a type-safe `null`, where `Nothing` is `null` and `Just x`
-- | is the non-null value `x`.
data Maybe a = Nothing | Just a
```

翻译:

```
`Maybe`类型用于表示可选值，类似于类型安全的`null`，其中`Nothing`为`null`，`Just x`为非空值`x`。
```

它实现了Functor类型类:

```haskell
instance functorMaybe :: Functor Maybe where
  map fn (Just x) = Just (fn x)
  map _  _        = Nothing
```

## 上下文

那么,如果一个值是Maybe Int类型的,意味着什么?

可以从不同的角度考察这个问题,但这里我们的答案是,这是一个Int类型的值,只是它在Maybe的上下文中.(或者在Maybe的"效果(effect)"中).

Maybe的效果是,某个值可能存在,也可能不存在.

如果一个值是Maybe Int类型,那么意味着这是一个"可能不存在"的Int类型的值.

是的, 不要把Maybe Int看作是Maybe类型的Int泛型,而是看作一个特别的Int类型,在有些时候这样的观点非常有帮助.

## 函数提升

既然它是如此特殊的一个值,自然无法用普通的函数进行计算:如果我们有一个Int->Int的函数,是无法用Maybe Int的值调用它的.

而类型类是一种"描述能力的接口",Functor类型类描述的是"在上下文中操作这个值的能力".

幸运的是,Maybe实现了Functor类型类,这意味着我们可以用Int->Int的函数操作这个"可能不存在的Int值"了,只要提升一下函数就可以.

那要如何操作?这就看Maybe类型对Functor类型类的具体实现了.Maybe的想法是,如果有值,就拿函数计算,如果没有值,就不计算直接返回Nothing.

接下来我们还会看到很多类型和类型类,但理解是一样的,类型是一种上下文,而类型类描述实现它的类型可以做什么,而具体的行为在类型中实现.

## List

另一个例子是List类型, 比如, 如果一个值是List Int类型, 意味着什么?

一个观点是, 意味着一个"多重可能性"的值.比如,我们有一个函数add1:

```haskell
add1 :: Int -> Int
add1 a = a + 1
```

现在我们拿一个数字调用它,比如1吧,那么我们会得到2.

那么如果是一个"多重可能性的值"呢?比如一个值,它可能是1,也有可能是2,也有可能是3.这就是List.

显然,我们的add1无法处理这种情况,但List实现了Functor类型类,这意味着我们拥有"在上下文中操作这个值的能力".

那么用提升过的add1操作"可能是1,也有可能是2,也有可能是3"的值,会得到什么呢?

会得到另一个多重可能性是值,它可能是2,可能是3,也可能是4.在List的角度来看,倒也合理.

## Applicative

Apply和Applicative是另外两个类型类,其中要实现Applicative必须要先实现Apply.为了方便,这里我们只讨论Applicative.

Applicative表示的是"合并多个效果的能力".

简单的说, Applicative要求在Functor的基础上再实现两个函数, apply和pure.

```haskell
apply :: forall a b. f (a -> b) -> f a -> f b
pure :: forall a. a -> f a
```

pure意味着可以将任何类型的值放入给定的上下文中,只要这个上下文实现了Applicative类型类.

### lift

再看看apply,考虑它的签名:

```haskell
apply :: f (a -> b) -> f a -> f b
```

如果令其中的b等于c->d,则可以写成:

```haskell
apply :: f (a -> c -> d) -> f a -> f (c -> d)
```

意味着, 使用`f (a -> c -> d)`和一个`f a`的值调用apply, 会得到一个`f (c -> d)`的值.

而如果对`f (c -> d)`的值和一个`f c`的值调用apply,套用开始的公式,将其中的a改成c,b改成d,会得到f d类型的值:

```haskell
apply :: f (c -> d) -> f c -> f d
```

那么不难想象, 可以构造一个函数, 输入一个`f (a -> c -> d)`, 然后连续调用两次`apply`, 它的签名是:

```haskell
??? :: f (a -> c -> d) -> f a -> f c -> f d
```

问题是, `f (a -> c -> d)`哪里去搞?直观的看,因为我们有pure,所以我们可以很轻松的把`a -> c -> d`变成`f (a -> c -> d)`.

实际上,我们通常不用pure,而是用map结合函数的不全调用,不过这里为了简单就不讨论过多细节了.

于是有这样的函数:

```haskell
lift2 :: forall a b c f. Apply f => (a -> b -> c) -> f a -> f b -> f c
```

与此类似,我们还有lift3,lift4,lift5,...,甚至可以做出任意参数的函数的提升.

### 合并上下文

从这个签名可以解读出另一个意思:对于任何实现Apply类型类的类型f而言,可以将f a和f b的数据合成为f c的数据.

也就是说, 将两个上下文相同的值通过某种给定的方法进行合并, 得到一个相同上下文的值. 也就是上下文的合并. 

拿Maybe来说, 意味着只要给出合适的函数, 就可以将两个Maybe上下文的值合并为另一个Maybe上下文的值.

这并不是看起来那么简单, 如果map规定了一个带有上下文的值如何被函数操作的话,apply就是规定多个上下文的值如何被函数操作了.

Maybe对此的答案是:如果两个值中任何一个是Nothing,就会得到Nothing.想想也合理.

而List对此的答案是:做笛卡尔积后拉平.

```haskell
> lift2 (\a b -> a + b) (1:2:3:Nil) (4:5:6:Nil) 
(5 : 6 : 7 : 6 : 7 : 8 : 7 : 8 : 9 : Nil)
```

确实也合理,x可能是1,2,3中的任何一个,y可能是4,5,6中的任何一个,现在问x+y的所有可能,不就是这个答案吗.

请注意,合并上下文意味着我们得到的结果中包含了(参考了)被合并的两个上下文的情况.

考虑一个更明显的例子,有一个类型是`IO`,一个`IO Int`类型的数据, 意味着, 一个Int类型的值, 但要获取它, 必须要经过一个IO操作.

那么,`apply (Int->String->Boolean) (IO Int) (IO String)`意味着什么?

合理的实现是, 你会得到一个`IO Boolean`类型的值, 当实际获取这个Boolean值时, 会执行合并前的两个IO操作.

## Monad

另一个类型类是Monad,它继承Applicative,同时规定了一个接口:

```haskell
bind :: m a -> (a -> m b) -> m b
```

这里有一些争论, 例如其实Monad继承Applicative[并不是必须的](https://wiki.haskell.org/Functor-Applicative-Monad_Proposal).但我们还是以传统的方式来解释,我们还是认为Monad是要继承Applicative的.

解释Monad的文章[非常多](https://wiki.haskell.org/Monad_tutorials_timeline), 因为有不同的侧重点, 所以解释不同也可以理解.

这里, 我们的解释是, Monad提供了一种更加动态的操作上下文的方法.

### 动态操作

考虑现在有三个IO数据,他们的类型都是`IO Int`,我们想把他合成一个.合成的方法有很多种,我们希望把他们都加起来吧.

我们可以用litf3, 只要输入一个`Int->Int->Int->Int`的函数就可以了, 最后我们会获得一个`IO Int`的值.

得到的这个值意味着, 这是一个Int类型的值, 但要获得它, 我们必须进行一次IO计算, 因为这个IO又是合成的, 所以他会执行合成它的那三个IO的计算.

那如果, 我想做判断呢?比如,如果第一个值的结果是某值, 我就返回第一个值+第二个值, 否则就返回第一个值+第三个值.这也算是一种上下文合并,只是有条件判断.

当然. 你可以在`a->a->a->b`的那个函数里进行判断, 但是无论如何, 这三个IO值全部都会被计算.但我们需要只计算其中两个IO,产生两次副作用就够了.

我承认这个例子很烂, 但我没想到更好的例子.

Monad则可以按我们需要的工作:

```haskell
fun :: IO Int -> IO Int -> IO Int -> IO Int  
fun v1 v2 v3 = bind v1 (\a -> if (a == 1) then (map (\b -> a+b) v2) else (map (\c -> a+c) v3))
```

因为bind可以被写为中缀`>>=`,所以可以写成:

```haskell
fun :: IO Int -> IO Int -> IO Int -> IO Int  
fun v1 v2 v3 = v1 >>= \a ->
  if (a == 1) then
    map (\b -> a+b) v2
  else
    map (\c -> a+c) v3
```

还可以写成do表达式:

```haskell
fun :: IO Int -> IO Int -> IO Int -> IO Int  
fun v1 v2 v3 = do
  a <- v1
  if (a == 1) then
    map (\b -> a+b) v2
  else
    map (\c -> a+c) v3
```

### bind

从上面的例子可以看出, bind允许你计算一个效果, 把效果的值输入一个函数进行运算, 只要这个函数返回的值也带有这个上下文就行了.

厉害的地方是, 函数是可以随便写的, 我们可以在函数里做任何事, 条件判断自然也不是问题了.

更神奇的地方是, 函数里可以继续使用bind计算其他的上下文, 而闭包特性让我们可以同时访问到多个上下文内的值.

结合do表达式,就像是普通的过程式编程一样.

```haskell
fun :: Maybe Int -> Maybe Int -> Maybe Int  
fun v1 v2 = do
  a <- v1
  b <- v2
  pure $ a + b
```

### 与IO的关系

公平的说, Applicative也可以做到同时访问多个上下文的值.

对于第一个例子(三个IO Int的例子), 如果把IO换成Maybe, 完全可以用Applicative的lift3获得一样的结果.

因为计算Maybe的上下文不会带来什么副作用, 没有副作用的话, 到底是计算了两个上下文还是计算了三个上下文, 没有什么关系.

但特别的, 如果上下文是IO操作的话, 对外部是有影响的. 就像例子里演示的那样, 这时Applicative和Monad就有区别了.

所以Monad经常和副作用联系在一起.

### 顺序性

注意到, Monad暗示了一种顺序性, 你可以"先"做什么, 然后"再"做什么.

但Applicative没有, 以这个例子而言:`apply (Int->String->Boolean) (IO Int) (IO String)`.

我们并不强调IO Int和IO String中哪一个上下文先被计算,他们可以是"一起"计算的.

## 副作用

程序总归是要产生副作用的, 但我们又希望编写程序时排除副作用的干扰.

在这里, 我们只有两个东西:值和函数, 严格的说函数也是值, 所以我们只有值.

特别的是, 值可以带有上下文, 要获取一个带有上下文的值, 必须要计算上下文, 所谓的上下文, 就是我们的类型.

又有一种特别的上下文, 那就是IO, 他表示副作用.

我们编写的函数并没有任何副作用, 只是值和值之间的转换罢了, 即使是涉及到IO上下文的函数, 也只是值与值之间的转换而已.

真正执行副作用的是程序之外的东西, 我们的main函数会返回一个IO Void类型的值, 这个值会在我们的程序之外被计算上下文, 相关的副作用也就都被执行了.
