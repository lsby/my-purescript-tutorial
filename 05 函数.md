# 函数

## 加一

我们可以简单的写出一个"加一"的函数.

```haskell
add1 :: Int -> Int
add1 a = a + 1
```

其中

```haskell
add1 :: Int -> Int
```

是函数的类型签名,表示`add1`函数,接受一个`Int`类型的参数,返回一个`Int`类型的值.

而

```haskell
add1 a = a + 1
```

是`add1`函数的实现,其中这个`a`就是输入的那个`Int`类型的参数, 也就是形式参数 ,然后`a+1`就是函数体, 说明这个函数返回`a+1`.

我们可以调用:

```haskell
> add1 1
2
```

我们对比一下定义和调用:

```haskell
add1 a = a + 1  -- 定义
add1 1          -- 调用
```

可以看到, `add1 1`这次调用里, `a`就是`1`, 所以它等于`a + 1`也就是`1 + 1`也就是`2`.

请注意, 函数名和参数都必须是小写字母开头.

## 圆的面积

我们还是以圆形为例:

```haskell
data Circle = Normal_Circle Number Number Number | General_Circle Number Number Number
```

我们写一个函数计算圆的面积:

圆的面积是pi*(r^2),其中pi是圆周率,r是圆的半径.

再看看对圆的描述:

- 圆的标准式:(x-a)²+(y-b)²=r².
- 圆的一般式:x²+y²+Dx+Ey+F=0.

对于标准式,我们的参数是a,b,r,也就是说,我们要的r直接就有.

对于一般式,我们的参数是D,E,F,但要通过这个算半径也不难,百度到答案:(1/2)\*(sqrt(D^2+E^2-4\*F))

我们写计算圆面积的函数:

```haskell
circle_area :: Circle -> Number
circle_area (Normal_Circle a b r) = pi * (pow r 2.0)
circle_area (General_Circle d e f) = pi * (pow (0.5 * sqrt ((pow d 2.0) + (pow e 2.0) - (4.0 * f))) 2.0)
```

这串长长的计算太难看了, 可以用`where`更容易的表示:

```haskell
circle_area :: Circle -> Number
circle_area (Normal_Circle a b r) = pi * (pow r 2.0)
circle_area (General_Circle d e f) = pi * (pow r 2.0)
  where
    r = 0.5 * sqrt w
    w = pow d 2.0 + pow e 2.0 + pow f 2.0
```

这里用到的`pi`,`pow`,`sqrt`要从外模块引入.

https://pursuit.purescript.org/packages/purescript-math/3.0.0/docs/Math

你需要先安装它:

```bash
spago install math
```

还要编译一下:

```bash
spago build
```

然后引入它:

```haskell
import Math (pow, pi, sqrt)
```

你的文件现在看起来像是这样:

```haskell
module Main where

import Prelude
import Effect (Effect)
import Effect.Console (log)
import Math (pow, pi, sqrt)

data Circle = Normal_Circle Number Number Number | General_Circle Number Number Number

circle_area :: Circle -> Number
circle_area (Normal_Circle a b r) = pi * (pow r 2.0)
circle_area (General_Circle d e f) = pi * (pow r 2.0)
  where
    r = 0.5 * sqrt w
    w = pow d 2.0 + pow e 2.0 + pow f 2.0

main :: Effect Unit
main = do
  log "🍝"

```

试试:

```bash
> circle_area (Normal_Circle 1.0 2.0 3.0)
28.274333882308138

> circle_area (General_Circle 1.0 2.0 3.0)
10.995574287564276
```

当`circle_area (Normal_Circle 1 2 3)`时, 匹配到了这条实现:

```haskell
circle_area (Normal_Circle 1 2 3)                      -- 调用形式
circle_area (Normal_Circle a b r) = pi * (pow r 2)     -- 函数实现
```

`a`对应`1`,`b`对应`2`,`r`对应`3`,整体等于`pi * (pow r 2)`.

当`circle_area (General_Circle 1 2 3)`时, 匹配到了这条实现:

```haskell
circle_area (General_Circle 1 2 3)                          -- 调用形式
circle_area (General_Circle d e f) = pi * (pow r 2.0)       -- 函数实现
  where
    r = 0.5 * sqrt w
    w = pow d 2.0 + pow e 2.0 + pow f 2.0
```

`d`对应`1`,`e`对应`2`,`f`对应`3`.整体等于后面的表达式.

可以看到, 通过不同的构造子, 对应到了不同的函数实现上, 不同的参数通过不同的声明, 结构成了不同的形参, 这称为`模式匹配`.

模式匹配还有些细节, 会在之后讨论.

## 链表求和

再举一个例子,拿List来说:

```haskell
data List a = Nil | Cons a (List a)
```

这个刚才已经详细讨论过了.

我们写一个函数,把这个`List`里的所有数都加起来.

```haskell
sum :: List Int -> Int
sum Nil = 0
sum (Cons x xs) = x + sum xs
```

最后调用:

```bash
> sum (Cons 1 (Cons 2 (Cons 3 Nil)))
6
```

看看函数签名:

```haskell
sum :: List Int -> Int
```

注意到,输入参数是`List Int`,这里意味着,我们的函数只接受`Int`组成的`List`.

再看看函数实现:

如果匹配到`Nil`,直接返回`0`.

如果匹配到`Cons`,看看我们写的模式和实际的数据:

```haskell
Cons x xs                     -- 我们写的模式
Cons 3 Nil                    -- 数据3
Cons 2 (Cons 3 Nil))          -- 数据2
Cons 1 (Cons 2 (Cons 3 Nil))  -- 数据1
```

对于`Cons 1 (Cons 2 (Cons 3 Nil))`, `x`匹配到了`1`, `sx`匹配到了剩下的`Cons 2 (Cons 3 Nil)`, 整个返回`1 + sum (Cons 2 (Cons 3 Nil))`

对于`Cons 2 (Cons 3 Nil)`, `x`匹配到了`2`, `sx`匹配到了剩下的`Cons 3 Nil`, 整个返回`2 + sum (Cons 3 Nil)`

对于`Cons 3 Nil`, `x`匹配到了`3`, `sx`匹配到了剩下的`Nil`, 整个返回`3 + sum Nil`

最后, `sum Nil`得到`0`, 标准的递归.