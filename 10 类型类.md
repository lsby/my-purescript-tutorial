# 类型类

经过之前的介绍, 各位已经掌握了基础的编程能力, 现在来看看新的概念.

## 基本使用

之前我们说过`show`函数, 它可以神奇的将很多类型转为字符串.

```bash
> show (Cons 1 (Cons 2 (Cons 3 Nil)))
"(1 : 2 : 3 : Nil)"
> show [1,2,3]                       
"[1,2,3]"
> show {"a":1,"b":2}
"{ a: 1, b: 2 }"
> show {"a":[1,2,3],"b":(Cons 1 (Cons 2 (Cons 3 Nil)))}
"{ a: [1,2,3], b: (1 : 2 : 3 : Nil) }"
```

现在, 看看`show`的源码:

```haskell
class Show a where
  show :: a -> String
```

这是什么? 这叫`类型类`, 它定义了一个名叫`Show`的类型类, 并且规定, 凡是实现这个类型类的类型`a`, 都必须能被`show`函数转换为字符串.

注意大小写, 类型类和类型一样, 是大写字母开头, 而类型类规定的函数, 像普通函数一样, 是小写字母开头.

下面是各种类型对这个类型类的实现, 看几个:

```haskell
instance showBoolean :: Show Boolean where
  show true = "true"
  show false = "false"
```

其中, `instance`是实现类型类的标志, `showBoolean`是实现的名字, 这个名字是为了方便生成js代码的时候有更好的可读性, 实际上不重要.

接下来, `Show Boolean`表示, 要实现的类型是`Boolean`, 对比一下:

```haskell
class Show a where          -- 定义
      Show Boolean where    -- 实现
```

可以看到, 定义中的`a`, 在实现里就换成了`Boolean`.

下面也是一样, 定义里我们写了, `show :: a -> String`, 意思是, 有一个函数`show`, 可以把`a`类型转换为`String`类型.

在这里, 我们的`a`就是`Boolean`, 所以我们要实现一个`show`函数, 它的签名是`Boolean -> String`.

这个实现就是下面写的:

```haskell
  show true = "true"
  show false = "false"
```

## 自动重载

当定义好这一切后, 只需要`show 值`, 编译器会自动判断这个值是什么类型, 然后去找到这个类型是如何实现这个接口的, 去调用它.

比如, 当我写`show true`的时候, 编译器首先会发现, `show`函数不是普通的函数, 是类型类`Show`规定的函数, 而`true`是一个`Boolean`类型的值.

接着编译器就会找到, `Boolean`类型实现了`Show`类型类, 进而找到我们刚才写的函数, 于是调用这个函数.

那么如果写的是`show (Cons 1 Nil)`呢? 系统就会发现, `(Cons 1 Nil)`是`List Int`类型的值, 就会去找`List Int`类型实现`Show`类型类, 所写的`show`函数.

虽然是一个函数, 但是参数不同, 调用的函数就不同, 这在一般的编程语言中称为`函数的重载`. 在这里, 只是换了一种写法, 本质上还是函数的重载.

## 泛型类型和约束

再看看其他的类型, 比如`Maybe`类型, 定义在`Data.Maybe`模块里.

这个类型之前我们没怎么说, 其实很简单, 定义是:

```haskell
data Maybe a = Nothing | Just a
```

有两个构造子, 一个是无参数的`Nothing`, 另一个是需要一个参数的`Just`, 参数是泛型的.

先不需要知道它什么意思, 总之看到这个类型定义, 你就已经可以简单使用它了.

比如`Nothing`是一个`Maybe a`类型的值, `Just 1`是一个`Maybe Int`类型的值, `Maybe`的`kind`类型是`Type -> Type`.

现在我们想让`Maybe`类型实现`Show`类型类.

这里有一个规定, 例如`class Show a where`中的`a`, 之前已经说过, 它表示一个类型, 但这个类型的`kind`类型一定是`Type`, 而不能是`Type -> Type`之类的.

也就是说, 写`class Show Maybe where`是不对的, 因为`Maybe`的`kind`类型是`Type -> Type`.

怎么样把`Type -> Type`换成`Type`? 丢一个类型给它就可以了, 比如`Maybe String`.

我们可以写:

```haskell
instance showMaybeString :: Show (Maybe String) where
  show (Just x) = "(Just " <> x <> ")"
  show Nothing  = "Nothing"
```

这样就对`Maybe String`类型, 实现了`Show`类型类, 我们看到:

```haskell
class Show a where                -- 定义
      Show (Maybe String) where   -- 实现
```

类型类定义中的`a`在这里是`Maybe String`, 那么, 接下来我就要实现一个函数, 这个函数叫`show`, 可以把`Maybe String`转换为`String`.

于是你就能理解, 下面的:

```haskell
  show (Just x) = "(Just " <> x <> ")"
  show Nothing  = "Nothing"
```

是合理的, 如果是`Nothing`, 会返回字符串形式的`Nothing`, 如果是`Just`构造出来的值, 一定可以知道`x`是字符串, 一个简单的字符串连接就可以了.

那么, 我们可以再实现`Maybe Boolean`:

```haskell
instance showMaybeBoolean :: Show (Maybe Boolean) where
  show (Just x) = "(Just " <> show x <> ")"
  show Nothing  = "Nothing"
```

基本没有变化, 唯一的变化是, 这里的`x`不是字符串, 而是布尔值了. 我们需要写一个布尔值转字符串的函数.

幸运的是, 刚才我们已经写过这样的函数了, 不就是`show`吗. 因为我们知道`Boolean`实现了`Show`类型类, 所以我们可以大胆的用`show x`.

一个一个类型去定义永远定义不完, 那么就使用泛型吧:

```haskell
instance showMaybe :: Show (Maybe a) where
  show (Just x) = "(Just " <> show x <> ")"
  show Nothing  = "Nothing"
```

这样, `x`就是`a`类型, 而`a`可以是任意类型, 如何把任意类型转成字符串呢? `show`并不是万能的, 只有实现了`Show`类型类的类型, 才可以使用`show`.

所以这样写是不安全的, 因为我们不能保证`a`类型一定实现了`Show`类型类.

幸运的是, 有一个写法可以表示这样的逻辑:

```haskell
instance showMaybe :: Show a => Show (Maybe a) where
  show (Just x) = "(Just " <> show x <> ")"
  show Nothing  = "Nothing"
```

`Show a =>`表示, 虽然`a`是任意类型, 但`a`必须是实现了`Show`类型类的类型.

这样我们就可以放心的使用`show x`了.

## 类型类的理解

为什么要搞出这个东西? 从一种意义上理解, 它想表达的是, "某个类型能做什么".

比如`Show`类型类, 它表示"可以被转换成字符串".

而实现这个类型类的类型, 就必须说明, 这个类型是怎么转换成字符串的.

在某种意义上, 这和一般编程语言的`接口`有一些相似的地方.

## 看几个类型类

### Eq

```haskell
-- | The `Eq` type class represents types which support decidable equality.
-- |
-- | `Eq` instances should satisfy the following laws:
-- |
-- | - Reflexivity: `x == x = true`
-- | - Symmetry: `x == y = y == x`
-- | - Transitivity: if `x == y` and `y == z` then `x == z`

class Eq a where
  eq :: a -> a -> Boolean
```

注释的翻译:

```
"Eq"类型类表示支持可判定相等的类型。
"Eq"实例应满足以下定律:
- 自反性: x == x = true
- 对称性: 如果 x == y 那么 y == x
- 传递性: 如果 x == y 并且 y == z 那么 x == z
```

所以说, 实现这个类型类的类型是"可以判断相等"的.

同时, 如果要实现它, 必须满足下面说的三条定律, 需要说明的是, 这些定律是程序员应该自己证明和实现的, 编译器并不会检查.

看看这些定律, 也是合理的:

- 自己和自己相等
- a和b相等 等价于 b和a相等
- a和b相等 且 b和c相等 那么 a也和c相等

试试:

```bash
> eq 1 2
false

> eq "Test" "Test"
true
```

请注意, "相等"是个模糊的概念, 对不同类型而言可能是不同的.

只要实现能满足类型签名, 并且满足注释所写的要求, 都是可以的.

### Ord

```haskell
-- | The `Ord` type class represents types which support comparisons with a
-- | _total order_.
-- |
-- | `Ord` instances should satisfy the laws of total orderings:
-- |
-- | - Reflexivity: `a <= a`
-- | - Antisymmetry: if `a <= b` and `b <= a` then `a = b`
-- | - Transitivity: if `a <= b` and `b <= c` then `a <= c`

data Ordering = LT | EQ | GT

class Eq a <= Ord a where
  compare :: a -> a -> Ordering
```

从注释来看, 简单的说, `Ord`表示可排序的.

这里也有定律, 定律也是合理的, 符合我们一般对"排序"的认知.

再次强调, 只要满足签名和注释的要求, 具体的实现取决于类型本身, 其实还是有很大自由度的.

想想, 对比"比大小"这件事, 如果是数字, 我们有数学可以参考, 如果是字符串呢? 当然可以靠字母表或`ASCII`码, 但说到底, 这些是人为的规定.

当你自己写一个类型, 想实现某个类型类时候, 实现是可以依靠自己的需要来定义的, 并没有绝对的标准.

排序的要点就是, 可以比大小, 比大小有三种情况, 大于, 小于, 等于.

而`class Eq a <= Ord a where`表示, 定义一个类型类`Ord`, 它继承`Eq`类型类.

就是说如果一个类型实现了`Ord`类型类, 就必须先要实现`Eq`类型类, 这也正常, 能判断相等是能排序的前提条件.

试试:

```bash
> compare 1 2
LT

> compare "A" "Z"
LT
```

### Semigroup

```haskell
-- | The `Semigroup` type class identifies an associative operation on a type.
-- |
-- | Instances are required to satisfy the following law:
-- |
-- | - Associativity: `(x <> y) <> z = x <> (y <> z)`

class Semigroup a where
  append :: a -> a -> a
```

简单的说, 实现这个类型类的类型是"可以合在一起"的.

看签名也可以看出来, 输入两个`a`类型的值, 返回一个`a`类型的值.

看到这个`<>`很熟悉了, 就是字符串拼接, 它对应的前缀函数是`append`.

字符串的`append`也完美实现了这个定义: 字符串的"合在一起", 不就是"字符串拼接"吗.

 ```bash
 > append "a" "b"
 "ab"
 ```

数组和`List`也可以很自然的也可以合在一起:

```bash
> append [1, 2, 3] [2, 3, 4]
[1, 2, 3, 2, 3, 4]
> append (1 : 2 : 3 : Nil) (2 : 3 : 4 : Nil)
(1 : 2 : 3 : 2 : 3 : 4 : Nil)
```

当然, "合在一起"是一个模糊的概念, 一个类型具体要怎么"合在一起", 是有一些自由度的.

如果你写了一个类型, 去实现这个类型类, 你可以自己规定它要怎么"合在一起", 只要符合签名和注释的要求, 并没有绝对的规则.

### Monoid

```haskell
-- | A `Monoid` is a `Semigroup` with a value `mempty`, which is both a
-- | left and right unit for the associative operation `<>`:
-- |
-- | - Left unit: `(mempty <> x) = x`
-- | - Right unit: `(x <> mempty) = x`
-- |
-- | `Monoid`s are commonly used as the result of fold operations, where
-- | `<>` is used to combine individual results, and `mempty` gives the result
-- | of folding an empty collection of elements.

class Semigroup m <= Monoid m where
  mempty :: m
```

简单的说, `Monoid`是有幺元的`Semigroup`. 就是说, 在`Semigroup`的基础上, 有一个值`mempty`, 它可以做到:

- (mempty <> x) = x
- (x <> mempty) = x

这个定义有点特殊, 至少上面的类型类说明是能看懂的: 一个类型若要实现`Monoid`类型, 必须先实现`Semigroup`类型类.

下面这个是什么意思呢? 是有一个值, 叫`mempty`, 它的类型是要实现的这个类型的类型.

比如, 如果`String`类型实现了`Monoid`类型类, 就意味着`mempty`是`String`类型.

如果`List Int`类型实现了`Monoid`类型类, 就意味着`mempty`是`List Int`类型.

这可以吗, 一个值可以有多个类型吗?

呃, 可以, 如果你直接看它的类型:

```bash
> :t mempty
forall (m :: Type). Monoid m => m
```

说明它是一个`m`类型, 而前面的`forall`又说明`m`是泛型, 只有一个约束, `m`必须是实现`Monoid`的类型.

其实这个和`Nil`很像:

```bash
> :t Nil
forall (t1 :: Type). List t1
```

我们之前说过, `Nil`表示任意的`List`类型.

在`(Cons 1 Nil)`的时候, `Nil`是`List Int`类型, 在`(Cons "a" Nil)`的时候, `Nil`是`List String`类型. 而单独的`Nil`, 就是`List a`类型.

这里, 单独的`mempty`就是`m`类型, 而它和其他东西一起用的时候:

```bash
> append mempty "a"   
"a"
> append mempty (1 : 2 : 3 : Nil)
(1 : 2 : 3 : Nil)
```

我们唯一知道关于`m`的事是, 它首先得实现`Semigroup`类型类.

那就意味着, `append`函数是可以操作它的, 因为`append`函数接收的两个参数都是实现`Semigroup`类型类的类型.

所以我们看到, `append mempty "a"`的时候, `append`应该接收两个`String`类型的值, 虽然我们不知道`mempty`是什么类型的值, 但我们知道`"a"`是`String`类型的值.

而我们又知道`append`是要接收两个相同类型的值作为参数的, 所以, 这时候, `mempty`就是`String`类型的值了.

相似的, `append mempty (1 : 2 : 3 : Nil)`的时候, `mempty`就变成`List Int`类型的值了.

再看看`List`类型对`Monoid`类型类的实现:

```haskell
instance monoidList :: Monoid (List a) where
  mempty = Nil
```

很简单, `Nil`而已.

所以才会看到, 把`mempty`和`(1 : 2 : 3 : Nil)`合在一起之后, 等于`(1 : 2 : 3 : Nil)`. 这也符合注释里写的定律.

### Foldable

```haskell
-- | `Foldable` represents data structures which can be _folded_.
-- |
-- | - `foldr` folds a structure from the right
-- | - `foldl` folds a structure from the left
-- | - `foldMap` folds a structure by accumulating values in a `Monoid`

class Foldable f where
  foldr :: forall a b. (a -> b -> b) -> b -> f a -> b
  foldl :: forall a b. (b -> a -> b) -> b -> f a -> b
  foldMap :: forall a m. Monoid m => (a -> m) -> f a -> m
```

实现这个类型类的类型是"可以折叠"的.

要实现这个类型类必须实现三个函数, `foldr`, `foldl`和`foldMap`.

其中, `foldr`和`foldl`之前我们说过, 来研究一下`foldMap`, 先看一下`foldMap`的签名:

它有两个泛型, `a`和`m`, 其中`m`必须实现了`Monoid`类型类, 也就是说`m`可以"合在一起", 同时`mempty`可以是`m`类型的值.

它输入一个`a`类型到`m`类型的函数, 和一个可以折叠类型的值, 这个可折叠类型的泛型也是`a`. 最后, 返回一个`m`类型的值.

结合签名和注释的说法来猜猜它的行为:

把`f a`想象成`List`, 比如`List Int`, 那么`a->m`的函数就是`Int -> 某个实现Monoid的类型m`. 我们假装`m`是字符串吧, 那么函数写`\a -> show a`.

而最后返回的`m`类型的值, 可以想到`m`是可以通过`append`合并的, 最后返回的应该是`List`的每个元素被处函数处理后, 得到的结果的合并.

试试:

```bash
> foldMap (\a -> show a) (1:2:3:4:5:Nil)
"12345"
```

那如果`m`是其他的呢, 比如是个数组:

```bash
> foldMap (\a -> [a+1]) (1:2:3:4:5:Nil)
[2,3,4,5,6]
```

看起来我们猜对了.

不过需要说明的是, 这样的猜对了仅仅是运气好而已.

这个类型类没有定律的规定, 注释也只是简单的说"在`Monoid`中积累值", 并没有详细说明细节.

如果你不知道类型类到底想表示什么, 或者不知道怎么用自己的类型实现类型类, 就看看类型类的注释, 再看看各种类型对它的实现.

来看看`List`的实现:

```haskell
instance foldableList :: Foldable List where
  foldr f b = foldl (flip f) b <<< rev
    where
    rev = go Nil
      where
      go acc Nil = acc
      go acc (x : xs) = go (x : acc) xs
  foldl f = go
    where
    go b = case _ of
      Nil -> b
      a : as -> go (f b a) as
  foldMap f = foldl (\acc -> append acc <<< f) mempty
```

复杂的`foldr`和`foldl`就不说了, 相信你也可以看懂.

这里我们看看`foldMap`, 这里用了`point-free`模式, 完整的写法是`foldMap f list = foldl (\acc -> append acc <<< f) mempty list`.

所以对于`List`而言, `foldMap`的行为就是以`mempty`为初始值, 将元素一个一个通过函数处理后, 使用`append`拼在一起.

### Functor

```haskell
-- | A `Functor` is a type constructor which supports a mapping operation
-- | `map`.
-- |
-- | `map` can be used to turn functions `a -> b` into functions
-- | `f a -> f b` whose argument and return types use the type constructor `f`
-- | to represent some computational context.
-- |
-- | Instances must satisfy the following laws:
-- |
-- | - Identity: `map identity = identity`
-- | - Composition: `map (f <<< g) = map f <<< map g`

class Functor f where
  map :: forall a b. (a -> b) -> f a -> f b
```

看看注释的说法: `map`将一个`a -> b`的函数转换为`f a -> f b`的函数.

什么意思? 看看例子就知道了.

看看对`Maybe`类型而言: 我们假设`a`是`Int`, `b`是`String`, `f`自然是`Maybe`啦. 签名是`map :: (Int -> String) -> Maybe Int -> Maybe String`.

写一个例子:

```haskell
fun :: (Int -> String) -> Maybe Int -> Maybe String
fun f a = map f a 
```

```bash
> fun (\a -> show a) (Just 1) 
(Just "1")

> fun (\a -> show a) Nothing  
Nothing
```

我们的函数`(\a -> show a)`, 它应该是`(Int -> String)`的, 而`map (\a -> show a)`后, 我们实际上得到了一个新的函数, 签名是`Maybe Int -> Maybe String`.

就是说这个新的函数输入`Maybe Int`类型的值, 返回`Maybe String`类型的值. 事实也正是如此, 我们输入了`(Just 1) `, 得到了`(Just "1")`.

而如果是`Nothing`, 我们就直接返回`Nothing`, 这也是符合签名的, 因为`Nothing`既可以看作`Maybe Int`, 也可以看作`Maybe String`.

再看看`List`类型的效果: 我们还是假设`a`是`Int`, `b`是`String`, `f`是`List`啦. 签名是`map :: (Int -> String) -> List Int -> List String`.

写一个例子:

```bash
> map (\a -> show a) (1:2:3:Nil)
("1" : "2" : "3" : Nil)
```

看起来行为是, 对`List`中的每一个元素都进行一次函数操作, 确实, 这样就可以把`List Int`转换为`List String`了.

所以, 如果一个类型`f`实现了`Functor`类型类, 就意味着:

我们可以把一个`a -> b`的函数, 通过`map`处理后, 得到一个新函数, 这个新函数可以操作这个`f`类型.

当然, 具体如何操作, 由类型自己实现, 只要满足签名和注释写的定律即可.

这有什么用呢? 之后我们会再讨论.

## 多参数类型类

类型类也是可以多参数的, 我们来自己写一个:

```haskell
class Split a b where
  uncons :: a -> Maybe { head :: b, tail :: a }
```

类型类`Split`是表示"可以被拆分"的概念的. `a`是容器类型, `b`是元素类型. 有一个函数`uncons`可以把容器分成第一个元素和剩下的元素.

比如, `a`可以是`List Int`, 那么`b`就是`Int`. 有一个函数`uncons`就可以把`(1:2:3:Nil)`转换成`Just { head :: 1, tail :: (2:3:Nil) }`

同时, `a`也可以是`String`, 那么`b`就是Char. 有一个函数`uncons`就可以把`"123"`转换成`Just { head :: '1', tail :: "23" }`

幸运的是, 这两个类型的`uncons`函数已经有人帮忙写好了.

于是完整代码:

```haskell
module Main where

import Prelude

import Data.List (List)
import Data.List as List
import Data.Maybe (Maybe)
import Data.String.CodeUnits as String
import Effect (Effect)
import Effect.Console (log)

class Split a b where
  my_uncons :: a -> Maybe { head :: b, tail :: a }

instance unconsArray :: Split (List a) a where
  my_uncons list = List.uncons list

instance unconsString :: Split String Char where
  my_uncons s = String.uncons s

main :: Effect Unit
main = do
  log "🍝"
```

试试:

```bash
> my_uncons "123"
```

居然报错了, 为什么呢. 

因为类型匹配不完整, 按泛型匹配, `class Split a b where`中的b, 也就是`instance unconsString :: Split String Char where`中的`Char`.

但是我的输入只有一个`String`类型的值, 没有出现`Char`, 编译器就不知道要调用谁了.

一个方法是, 写一个函数, 写清楚类型, 给编译器提供更多信息:

```haskell
fun :: String -> Maybe { head :: Char, tail :: String }
fun s = my_uncons s
```

就可以正常使用了:

```bash
> fun "123"
(Just { head: '1', tail: "23" })
```

另一个方法是:

```haskell
class Split a b | a -> b where
  my_uncons :: a -> Maybe { head :: b, tail :: a }
```

这后面的`| a -> b`称为`函数依赖`, 这样写就是告诉编译器, 存在一个函数, 这个函数可以把`a`类型的值`b`类型的值.

这样, 编译器知道了`a`类型, 就同时知道了`b`类型.

试试:

```bash
> my_uncons "123"
(Just { head: '1', tail: "23" })
> my_uncons (1:2:3:Nil)
(Just { head: 1, tail: (2 : 3 : Nil) })
```

## 空类型类

看看模式匹配不全的匿名函数的类型, 比如写一个, 输入二元数组, 将元素相加的函数:

```bash
> f = (\[a, b] -> a + b)
> :t f
forall (t3 :: Type). Partial => Semiring t3 => Array t3 -> t3
```

注意到, 类型约束是`Partial =>`. 奇怪的是, `Partial`后面居然没跟泛型变量.

这是种特殊的规定, 你无法直接使用这个函数.

而我们之前用过`unsafePartial`, 可以解除这个限制:

```bash
> unsafePartial f [1,2]
3
```

这算是某种特殊写法.



