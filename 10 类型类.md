# ç±»å‹ç±»

ç»è¿‡ä¹‹å‰çš„ä»‹ç», å„ä½å·²ç»æŒæ¡äº†åŸºç¡€çš„ç¼–ç¨‹èƒ½åŠ›, ç°åœ¨æ¥çœ‹çœ‹æ–°çš„æ¦‚å¿µ.

## åŸºæœ¬ä½¿ç”¨

ä¹‹å‰æˆ‘ä»¬è¯´è¿‡`show`å‡½æ•°, å®ƒå¯ä»¥ç¥å¥‡çš„å°†å¾ˆå¤šç±»å‹è½¬ä¸ºå­—ç¬¦ä¸².

```bash
> show (Cons 1 (Cons 2 (Cons 3 Nil)))
"(1 : 2 : 3 : Nil)"
> show [1,2,3]                       
"[1,2,3]"
> show {"a":1,"b":2}
"{ a: 1, b: 2 }"
> show {"a":[1,2,3],"b":(Cons 1 (Cons 2 (Cons 3 Nil)))}
"{ a: [1,2,3], b: (1 : 2 : 3 : Nil) }"
```

ç°åœ¨, çœ‹çœ‹`show`çš„æºç :

```haskell
class Show a where
  show :: a -> String
```

è¿™æ˜¯ä»€ä¹ˆ? è¿™å«`ç±»å‹ç±»`, å®ƒå®šä¹‰äº†ä¸€ä¸ªåå«`Show`çš„ç±»å‹ç±», å¹¶ä¸”è§„å®š, å‡¡æ˜¯å®ç°è¿™ä¸ªç±»å‹ç±»çš„ç±»å‹`a`, éƒ½å¿…é¡»èƒ½è¢«`show`å‡½æ•°è½¬æ¢ä¸ºå­—ç¬¦ä¸².

æ³¨æ„å¤§å°å†™, ç±»å‹ç±»å’Œç±»å‹ä¸€æ ·, æ˜¯å¤§å†™å­—æ¯å¼€å¤´, è€Œç±»å‹ç±»è§„å®šçš„å‡½æ•°, åƒæ™®é€šå‡½æ•°ä¸€æ ·, æ˜¯å°å†™å­—æ¯å¼€å¤´.

ä¸‹é¢æ˜¯å„ç§ç±»å‹å¯¹è¿™ä¸ªç±»å‹ç±»çš„å®ç°, çœ‹å‡ ä¸ª:

```haskell
instance showBoolean :: Show Boolean where
  show true = "true"
  show false = "false"
```

å…¶ä¸­, `instance`æ˜¯å®ç°ç±»å‹ç±»çš„æ ‡å¿—, `showBoolean`æ˜¯å®ç°çš„åå­—, è¿™ä¸ªåå­—æ˜¯ä¸ºäº†æ–¹ä¾¿ç”Ÿæˆjsä»£ç çš„æ—¶å€™æœ‰æ›´å¥½çš„å¯è¯»æ€§, å®é™…ä¸Šä¸é‡è¦.

æ¥ä¸‹æ¥, `Show Boolean`è¡¨ç¤º, è¦å®ç°çš„ç±»å‹æ˜¯`Boolean`, å¯¹æ¯”ä¸€ä¸‹:

```haskell
class Show a where          -- å®šä¹‰
      Show Boolean where    -- å®ç°
```

å¯ä»¥çœ‹åˆ°, å®šä¹‰ä¸­çš„`a`, åœ¨å®ç°é‡Œå°±æ¢æˆäº†`Boolean`.

ä¸‹é¢ä¹Ÿæ˜¯ä¸€æ ·, å®šä¹‰é‡Œæˆ‘ä»¬å†™äº†, `show :: a -> String`, æ„æ€æ˜¯, æœ‰ä¸€ä¸ªå‡½æ•°`show`, å¯ä»¥æŠŠ`a`ç±»å‹è½¬æ¢ä¸º`String`ç±»å‹.

åœ¨è¿™é‡Œ, æˆ‘ä»¬çš„`a`å°±æ˜¯`Boolean`, æ‰€ä»¥æˆ‘ä»¬è¦å®ç°ä¸€ä¸ª`show`å‡½æ•°, å®ƒçš„ç­¾åæ˜¯`Boolean -> String`.

è¿™ä¸ªå®ç°å°±æ˜¯ä¸‹é¢å†™çš„:

```haskell
  show true = "true"
  show false = "false"
```

## è‡ªåŠ¨é‡è½½

å½“å®šä¹‰å¥½è¿™ä¸€åˆ‡å, åªéœ€è¦`show å€¼`, ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨åˆ¤æ–­è¿™ä¸ªå€¼æ˜¯ä»€ä¹ˆç±»å‹, ç„¶åå»æ‰¾åˆ°è¿™ä¸ªç±»å‹æ˜¯å¦‚ä½•å®ç°è¿™ä¸ªæ¥å£çš„, å»è°ƒç”¨å®ƒ.

æ¯”å¦‚, å½“æˆ‘å†™`show true`çš„æ—¶å€™, ç¼–è¯‘å™¨é¦–å…ˆä¼šå‘ç°, `show`å‡½æ•°ä¸æ˜¯æ™®é€šçš„å‡½æ•°, æ˜¯ç±»å‹ç±»`Show`è§„å®šçš„å‡½æ•°, è€Œ`true`æ˜¯ä¸€ä¸ª`Boolean`ç±»å‹çš„å€¼.

æ¥ç€ç¼–è¯‘å™¨å°±ä¼šæ‰¾åˆ°, `Boolean`ç±»å‹å®ç°äº†`Show`ç±»å‹ç±», è¿›è€Œæ‰¾åˆ°æˆ‘ä»¬åˆšæ‰å†™çš„å‡½æ•°, äºæ˜¯è°ƒç”¨è¿™ä¸ªå‡½æ•°.

é‚£ä¹ˆå¦‚æœå†™çš„æ˜¯`show (Cons 1 Nil)`å‘¢? ç³»ç»Ÿå°±ä¼šå‘ç°, `(Cons 1 Nil)`æ˜¯`List Int`ç±»å‹çš„å€¼, å°±ä¼šå»æ‰¾`List Int`ç±»å‹å®ç°`Show`ç±»å‹ç±», æ‰€å†™çš„`show`å‡½æ•°.

è™½ç„¶æ˜¯ä¸€ä¸ªå‡½æ•°, ä½†æ˜¯å‚æ•°ä¸åŒ, è°ƒç”¨çš„å‡½æ•°å°±ä¸åŒ, è¿™åœ¨ä¸€èˆ¬çš„ç¼–ç¨‹è¯­è¨€ä¸­ç§°ä¸º`å‡½æ•°çš„é‡è½½`. åœ¨è¿™é‡Œ, åªæ˜¯æ¢äº†ä¸€ç§å†™æ³•, æœ¬è´¨ä¸Šè¿˜æ˜¯å‡½æ•°çš„é‡è½½.

## æ³›å‹ç±»å‹å’Œçº¦æŸ

å†çœ‹çœ‹å…¶ä»–çš„ç±»å‹, æ¯”å¦‚`Maybe`ç±»å‹, å®šä¹‰åœ¨`Data.Maybe`æ¨¡å—é‡Œ.

è¿™ä¸ªç±»å‹ä¹‹å‰æˆ‘ä»¬æ²¡æ€ä¹ˆè¯´, å…¶å®å¾ˆç®€å•, å®šä¹‰æ˜¯:

```haskell
data Maybe a = Nothing | Just a
```

æœ‰ä¸¤ä¸ªæ„é€ å­, ä¸€ä¸ªæ˜¯æ— å‚æ•°çš„`Nothing`, å¦ä¸€ä¸ªæ˜¯éœ€è¦ä¸€ä¸ªå‚æ•°çš„`Just`, å‚æ•°æ˜¯æ³›å‹çš„.

å…ˆä¸éœ€è¦çŸ¥é“å®ƒä»€ä¹ˆæ„æ€, æ€»ä¹‹çœ‹åˆ°è¿™ä¸ªç±»å‹å®šä¹‰, ä½ å°±å·²ç»å¯ä»¥ç®€å•ä½¿ç”¨å®ƒäº†.

æ¯”å¦‚`Nothing`æ˜¯ä¸€ä¸ª`Maybe a`ç±»å‹çš„å€¼, `Just 1`æ˜¯ä¸€ä¸ª`Maybe Int`ç±»å‹çš„å€¼, `Maybe`çš„`kind`ç±»å‹æ˜¯`Type -> Type`.

ç°åœ¨æˆ‘ä»¬æƒ³è®©`Maybe`ç±»å‹å®ç°`Show`ç±»å‹ç±».

è¿™é‡Œæœ‰ä¸€ä¸ªè§„å®š, ä¾‹å¦‚`class Show a where`ä¸­çš„`a`, ä¹‹å‰å·²ç»è¯´è¿‡, å®ƒè¡¨ç¤ºä¸€ä¸ªç±»å‹, ä½†è¿™ä¸ªç±»å‹çš„`kind`ç±»å‹ä¸€å®šæ˜¯`Type`, è€Œä¸èƒ½æ˜¯`Type -> Type`ä¹‹ç±»çš„.

ä¹Ÿå°±æ˜¯è¯´, å†™`class Show Maybe where`æ˜¯ä¸å¯¹çš„, å› ä¸º`Maybe`çš„`kind`ç±»å‹æ˜¯`Type -> Type`.

æ€ä¹ˆæ ·æŠŠ`Type -> Type`æ¢æˆ`Type`? ä¸¢ä¸€ä¸ªç±»å‹ç»™å®ƒå°±å¯ä»¥äº†, æ¯”å¦‚`Maybe String`.

æˆ‘ä»¬å¯ä»¥å†™:

```haskell
instance showMaybeString :: Show (Maybe String) where
  show (Just x) = "(Just " <> x <> ")"
  show Nothing  = "Nothing"
```

è¿™æ ·å°±å¯¹`Maybe String`ç±»å‹, å®ç°äº†`Show`ç±»å‹ç±», æˆ‘ä»¬çœ‹åˆ°:

```haskell
class Show a where                -- å®šä¹‰
      Show (Maybe String) where   -- å®ç°
```

ç±»å‹ç±»å®šä¹‰ä¸­çš„`a`åœ¨è¿™é‡Œæ˜¯`Maybe String`, é‚£ä¹ˆ, æ¥ä¸‹æ¥æˆ‘å°±è¦å®ç°ä¸€ä¸ªå‡½æ•°, è¿™ä¸ªå‡½æ•°å«`show`, å¯ä»¥æŠŠ`Maybe String`è½¬æ¢ä¸º`String`.

äºæ˜¯ä½ å°±èƒ½ç†è§£, ä¸‹é¢çš„:

```haskell
  show (Just x) = "(Just " <> x <> ")"
  show Nothing  = "Nothing"
```

æ˜¯åˆç†çš„, å¦‚æœæ˜¯`Nothing`, ä¼šè¿”å›å­—ç¬¦ä¸²å½¢å¼çš„`Nothing`, å¦‚æœæ˜¯`Just`æ„é€ å‡ºæ¥çš„å€¼, ä¸€å®šå¯ä»¥çŸ¥é“`x`æ˜¯å­—ç¬¦ä¸², ä¸€ä¸ªç®€å•çš„å­—ç¬¦ä¸²è¿æ¥å°±å¯ä»¥äº†.

é‚£ä¹ˆ, æˆ‘ä»¬å¯ä»¥å†å®ç°`Maybe Boolean`:

```haskell
instance showMaybeBoolean :: Show (Maybe Boolean) where
  show (Just x) = "(Just " <> show x <> ")"
  show Nothing  = "Nothing"
```

åŸºæœ¬æ²¡æœ‰å˜åŒ–, å”¯ä¸€çš„å˜åŒ–æ˜¯, è¿™é‡Œçš„`x`ä¸æ˜¯å­—ç¬¦ä¸², è€Œæ˜¯å¸ƒå°”å€¼äº†. æˆ‘ä»¬éœ€è¦å†™ä¸€ä¸ªå¸ƒå°”å€¼è½¬å­—ç¬¦ä¸²çš„å‡½æ•°.

å¹¸è¿çš„æ˜¯, åˆšæ‰æˆ‘ä»¬å·²ç»å†™è¿‡è¿™æ ·çš„å‡½æ•°äº†, ä¸å°±æ˜¯`show`å—. å› ä¸ºæˆ‘ä»¬çŸ¥é“`Boolean`å®ç°äº†`Show`ç±»å‹ç±», æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¤§èƒ†çš„ç”¨`show x`.

ä¸€ä¸ªä¸€ä¸ªç±»å‹å»å®šä¹‰æ°¸è¿œå®šä¹‰ä¸å®Œ, é‚£ä¹ˆå°±ä½¿ç”¨æ³›å‹å§:

```haskell
instance showMaybe :: Show (Maybe a) where
  show (Just x) = "(Just " <> show x <> ")"
  show Nothing  = "Nothing"
```

è¿™æ ·, `x`å°±æ˜¯`a`ç±»å‹, è€Œ`a`å¯ä»¥æ˜¯ä»»æ„ç±»å‹, å¦‚ä½•æŠŠä»»æ„ç±»å‹è½¬æˆå­—ç¬¦ä¸²å‘¢? `show`å¹¶ä¸æ˜¯ä¸‡èƒ½çš„, åªæœ‰å®ç°äº†`Show`ç±»å‹ç±»çš„ç±»å‹, æ‰å¯ä»¥ä½¿ç”¨`show`.

æ‰€ä»¥è¿™æ ·å†™æ˜¯ä¸å®‰å…¨çš„, å› ä¸ºæˆ‘ä»¬ä¸èƒ½ä¿è¯`a`ç±»å‹ä¸€å®šå®ç°äº†`Show`ç±»å‹ç±».

å¹¸è¿çš„æ˜¯, æœ‰ä¸€ä¸ªå†™æ³•å¯ä»¥è¡¨ç¤ºè¿™æ ·çš„é€»è¾‘:

```haskell
instance showMaybe :: Show a => Show (Maybe a) where
  show (Just x) = "(Just " <> show x <> ")"
  show Nothing  = "Nothing"
```

`Show a =>`è¡¨ç¤º, è™½ç„¶`a`æ˜¯ä»»æ„ç±»å‹, ä½†`a`å¿…é¡»æ˜¯å®ç°äº†`Show`ç±»å‹ç±»çš„ç±»å‹.

è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥æ”¾å¿ƒçš„ä½¿ç”¨`show x`äº†.

## ç±»å‹ç±»çš„ç†è§£

ä¸ºä»€ä¹ˆè¦æå‡ºè¿™ä¸ªä¸œè¥¿? ä»ä¸€ç§æ„ä¹‰ä¸Šç†è§£, å®ƒæƒ³è¡¨è¾¾çš„æ˜¯, "æŸä¸ªç±»å‹èƒ½åšä»€ä¹ˆ".

æ¯”å¦‚`Show`ç±»å‹ç±», å®ƒè¡¨ç¤º"å¯ä»¥è¢«è½¬æ¢æˆå­—ç¬¦ä¸²".

è€Œå®ç°è¿™ä¸ªç±»å‹ç±»çš„ç±»å‹, å°±å¿…é¡»è¯´æ˜, è¿™ä¸ªç±»å‹æ˜¯æ€ä¹ˆè½¬æ¢æˆå­—ç¬¦ä¸²çš„.

åœ¨æŸç§æ„ä¹‰ä¸Š, è¿™å’Œä¸€èˆ¬ç¼–ç¨‹è¯­è¨€çš„`æ¥å£`æœ‰ä¸€äº›ç›¸ä¼¼çš„åœ°æ–¹.

## çœ‹å‡ ä¸ªç±»å‹ç±»

### Eq

```haskell
-- | The `Eq` type class represents types which support decidable equality.
-- |
-- | `Eq` instances should satisfy the following laws:
-- |
-- | - Reflexivity: `x == x = true`
-- | - Symmetry: `x == y = y == x`
-- | - Transitivity: if `x == y` and `y == z` then `x == z`

class Eq a where
  eq :: a -> a -> Boolean
```

æ³¨é‡Šçš„ç¿»è¯‘:

```
"Eq"ç±»å‹ç±»è¡¨ç¤ºæ”¯æŒå¯åˆ¤å®šç›¸ç­‰çš„ç±»å‹ã€‚
"Eq"å®ä¾‹åº”æ»¡è¶³ä»¥ä¸‹å®šå¾‹:
- è‡ªåæ€§: x == x = true
- å¯¹ç§°æ€§: å¦‚æœ x == y é‚£ä¹ˆ y == x
- ä¼ é€’æ€§: å¦‚æœ x == y å¹¶ä¸” y == z é‚£ä¹ˆ x == z
```

æ‰€ä»¥è¯´, å®ç°è¿™ä¸ªç±»å‹ç±»çš„ç±»å‹æ˜¯"å¯ä»¥åˆ¤æ–­ç›¸ç­‰"çš„.

åŒæ—¶, å¦‚æœè¦å®ç°å®ƒ, å¿…é¡»æ»¡è¶³ä¸‹é¢è¯´çš„ä¸‰æ¡å®šå¾‹, éœ€è¦è¯´æ˜çš„æ˜¯, è¿™äº›å®šå¾‹æ˜¯ç¨‹åºå‘˜åº”è¯¥è‡ªå·±è¯æ˜å’Œå®ç°çš„, ç¼–è¯‘å™¨å¹¶ä¸ä¼šæ£€æŸ¥.

çœ‹çœ‹è¿™äº›å®šå¾‹, ä¹Ÿæ˜¯åˆç†çš„:

- è‡ªå·±å’Œè‡ªå·±ç›¸ç­‰
- aå’Œbç›¸ç­‰ ç­‰ä»·äº bå’Œaç›¸ç­‰
- aå’Œbç›¸ç­‰ ä¸” bå’Œcç›¸ç­‰ é‚£ä¹ˆ aä¹Ÿå’Œcç›¸ç­‰

è¯•è¯•:

```bash
> eq 1 2
false

> eq "Test" "Test"
true
```

è¯·æ³¨æ„, "ç›¸ç­‰"æ˜¯ä¸ªæ¨¡ç³Šçš„æ¦‚å¿µ, å¯¹ä¸åŒç±»å‹è€Œè¨€å¯èƒ½æ˜¯ä¸åŒçš„.

åªè¦å®ç°èƒ½æ»¡è¶³ç±»å‹ç­¾å, å¹¶ä¸”æ»¡è¶³æ³¨é‡Šæ‰€å†™çš„è¦æ±‚, éƒ½æ˜¯å¯ä»¥çš„.

### Ord

```haskell
-- | The `Ord` type class represents types which support comparisons with a
-- | _total order_.
-- |
-- | `Ord` instances should satisfy the laws of total orderings:
-- |
-- | - Reflexivity: `a <= a`
-- | - Antisymmetry: if `a <= b` and `b <= a` then `a = b`
-- | - Transitivity: if `a <= b` and `b <= c` then `a <= c`

data Ordering = LT | EQ | GT

class Eq a <= Ord a where
  compare :: a -> a -> Ordering
```

ä»æ³¨é‡Šæ¥çœ‹, ç®€å•çš„è¯´, `Ord`è¡¨ç¤ºå¯æ’åºçš„.

è¿™é‡Œä¹Ÿæœ‰å®šå¾‹, å®šå¾‹ä¹Ÿæ˜¯åˆç†çš„, ç¬¦åˆæˆ‘ä»¬ä¸€èˆ¬å¯¹"æ’åº"çš„è®¤çŸ¥.

å†æ¬¡å¼ºè°ƒ, åªè¦æ»¡è¶³ç­¾åå’Œæ³¨é‡Šçš„è¦æ±‚, å…·ä½“çš„å®ç°å–å†³äºç±»å‹æœ¬èº«, å…¶å®è¿˜æ˜¯æœ‰å¾ˆå¤§è‡ªç”±åº¦çš„.

æƒ³æƒ³, å¯¹æ¯”"æ¯”å¤§å°"è¿™ä»¶äº‹, å¦‚æœæ˜¯æ•°å­—, æˆ‘ä»¬æœ‰æ•°å­¦å¯ä»¥å‚è€ƒ, å¦‚æœæ˜¯å­—ç¬¦ä¸²å‘¢? å½“ç„¶å¯ä»¥é å­—æ¯è¡¨æˆ–`ASCII`ç , ä½†è¯´åˆ°åº•, è¿™äº›æ˜¯äººä¸ºçš„è§„å®š.

å½“ä½ è‡ªå·±å†™ä¸€ä¸ªç±»å‹, æƒ³å®ç°æŸä¸ªç±»å‹ç±»æ—¶å€™, å®ç°æ˜¯å¯ä»¥ä¾é è‡ªå·±çš„éœ€è¦æ¥å®šä¹‰çš„, å¹¶æ²¡æœ‰ç»å¯¹çš„æ ‡å‡†.

æ’åºçš„è¦ç‚¹å°±æ˜¯, å¯ä»¥æ¯”å¤§å°, æ¯”å¤§å°æœ‰ä¸‰ç§æƒ…å†µ, å¤§äº, å°äº, ç­‰äº.

è€Œ`class Eq a <= Ord a where`è¡¨ç¤º, å®šä¹‰ä¸€ä¸ªç±»å‹ç±»`Ord`, å®ƒç»§æ‰¿`Eq`ç±»å‹ç±».

å°±æ˜¯è¯´å¦‚æœä¸€ä¸ªç±»å‹å®ç°äº†`Ord`ç±»å‹ç±», å°±å¿…é¡»å…ˆè¦å®ç°`Eq`ç±»å‹ç±», è¿™ä¹Ÿæ­£å¸¸, èƒ½åˆ¤æ–­ç›¸ç­‰æ˜¯èƒ½æ’åºçš„å‰ææ¡ä»¶.

è¯•è¯•:

```bash
> compare 1 2
LT

> compare "A" "Z"
LT
```

### Semigroup

```haskell
-- | The `Semigroup` type class identifies an associative operation on a type.
-- |
-- | Instances are required to satisfy the following law:
-- |
-- | - Associativity: `(x <> y) <> z = x <> (y <> z)`

class Semigroup a where
  append :: a -> a -> a
```

ç®€å•çš„è¯´, å®ç°è¿™ä¸ªç±»å‹ç±»çš„ç±»å‹æ˜¯"å¯ä»¥åˆåœ¨ä¸€èµ·"çš„.

çœ‹ç­¾åä¹Ÿå¯ä»¥çœ‹å‡ºæ¥, è¾“å…¥ä¸¤ä¸ª`a`ç±»å‹çš„å€¼, è¿”å›ä¸€ä¸ª`a`ç±»å‹çš„å€¼.

çœ‹åˆ°è¿™ä¸ª`<>`å¾ˆç†Ÿæ‚‰äº†, å°±æ˜¯å­—ç¬¦ä¸²æ‹¼æ¥, å®ƒå¯¹åº”çš„å‰ç¼€å‡½æ•°æ˜¯`append`.

å­—ç¬¦ä¸²çš„`append`ä¹Ÿå®Œç¾å®ç°äº†è¿™ä¸ªå®šä¹‰: å­—ç¬¦ä¸²çš„"åˆåœ¨ä¸€èµ·", ä¸å°±æ˜¯"å­—ç¬¦ä¸²æ‹¼æ¥"å—.

 ```bash
 > append "a" "b"
 "ab"
 ```

æ•°ç»„å’Œ`List`ä¹Ÿå¯ä»¥å¾ˆè‡ªç„¶çš„ä¹Ÿå¯ä»¥åˆåœ¨ä¸€èµ·:

```bash
> append [1, 2, 3] [2, 3, 4]
[1, 2, 3, 2, 3, 4]
> append (1 : 2 : 3 : Nil) (2 : 3 : 4 : Nil)
(1 : 2 : 3 : 2 : 3 : 4 : Nil)
```

å½“ç„¶, "åˆåœ¨ä¸€èµ·"æ˜¯ä¸€ä¸ªæ¨¡ç³Šçš„æ¦‚å¿µ, ä¸€ä¸ªç±»å‹å…·ä½“è¦æ€ä¹ˆ"åˆåœ¨ä¸€èµ·", æ˜¯æœ‰ä¸€äº›è‡ªç”±åº¦çš„.

å¦‚æœä½ å†™äº†ä¸€ä¸ªç±»å‹, å»å®ç°è¿™ä¸ªç±»å‹ç±», ä½ å¯ä»¥è‡ªå·±è§„å®šå®ƒè¦æ€ä¹ˆ"åˆåœ¨ä¸€èµ·", åªè¦ç¬¦åˆç­¾åå’Œæ³¨é‡Šçš„è¦æ±‚, å¹¶æ²¡æœ‰ç»å¯¹çš„è§„åˆ™.

### Monoid

```haskell
-- | A `Monoid` is a `Semigroup` with a value `mempty`, which is both a
-- | left and right unit for the associative operation `<>`:
-- |
-- | - Left unit: `(mempty <> x) = x`
-- | - Right unit: `(x <> mempty) = x`
-- |
-- | `Monoid`s are commonly used as the result of fold operations, where
-- | `<>` is used to combine individual results, and `mempty` gives the result
-- | of folding an empty collection of elements.

class Semigroup m <= Monoid m where
  mempty :: m
```

ç®€å•çš„è¯´, `Monoid`æ˜¯æœ‰å¹ºå…ƒçš„`Semigroup`. å°±æ˜¯è¯´, åœ¨`Semigroup`çš„åŸºç¡€ä¸Š, æœ‰ä¸€ä¸ªå€¼`mempty`, å®ƒå¯ä»¥åšåˆ°:

- (mempty <> x) = x
- (x <> mempty) = x

è¿™ä¸ªå®šä¹‰æœ‰ç‚¹ç‰¹æ®Š, è‡³å°‘ä¸Šé¢çš„ç±»å‹ç±»è¯´æ˜æ˜¯èƒ½çœ‹æ‡‚çš„: ä¸€ä¸ªç±»å‹è‹¥è¦å®ç°`Monoid`ç±»å‹, å¿…é¡»å…ˆå®ç°`Semigroup`ç±»å‹ç±».

ä¸‹é¢è¿™ä¸ªæ˜¯ä»€ä¹ˆæ„æ€å‘¢? æ˜¯æœ‰ä¸€ä¸ªå€¼, å«`mempty`, å®ƒçš„ç±»å‹æ˜¯è¦å®ç°çš„è¿™ä¸ªç±»å‹çš„ç±»å‹.

æ¯”å¦‚, å¦‚æœ`String`ç±»å‹å®ç°äº†`Monoid`ç±»å‹ç±», å°±æ„å‘³ç€`mempty`æ˜¯`String`ç±»å‹.

å¦‚æœ`List Int`ç±»å‹å®ç°äº†`Monoid`ç±»å‹ç±», å°±æ„å‘³ç€`mempty`æ˜¯`List Int`ç±»å‹.

è¿™å¯ä»¥å—, ä¸€ä¸ªå€¼å¯ä»¥æœ‰å¤šä¸ªç±»å‹å—?

å‘ƒ, å¯ä»¥, å¦‚æœä½ ç›´æ¥çœ‹å®ƒçš„ç±»å‹:

```bash
> :t mempty
forall (m :: Type). Monoid m => m
```

è¯´æ˜å®ƒæ˜¯ä¸€ä¸ª`m`ç±»å‹, è€Œå‰é¢çš„`forall`åˆè¯´æ˜`m`æ˜¯æ³›å‹, åªæœ‰ä¸€ä¸ªçº¦æŸ, `m`å¿…é¡»æ˜¯å®ç°`Monoid`çš„ç±»å‹.

å…¶å®è¿™ä¸ªå’Œ`Nil`å¾ˆåƒ:

```bash
> :t Nil
forall (t1 :: Type). List t1
```

æˆ‘ä»¬ä¹‹å‰è¯´è¿‡, `Nil`è¡¨ç¤ºä»»æ„çš„`List`ç±»å‹.

åœ¨`(Cons 1 Nil)`çš„æ—¶å€™, `Nil`æ˜¯`List Int`ç±»å‹, åœ¨`(Cons "a" Nil)`çš„æ—¶å€™, `Nil`æ˜¯`List String`ç±»å‹. è€Œå•ç‹¬çš„`Nil`, å°±æ˜¯`List a`ç±»å‹.

è¿™é‡Œ, å•ç‹¬çš„`mempty`å°±æ˜¯`m`ç±»å‹, è€Œå®ƒå’Œå…¶ä»–ä¸œè¥¿ä¸€èµ·ç”¨çš„æ—¶å€™:

```bash
> append mempty "a"   
"a"
> append mempty (1 : 2 : 3 : Nil)
(1 : 2 : 3 : Nil)
```

æˆ‘ä»¬å”¯ä¸€çŸ¥é“å…³äº`m`çš„äº‹æ˜¯, å®ƒé¦–å…ˆå¾—å®ç°`Semigroup`ç±»å‹ç±».

é‚£å°±æ„å‘³ç€, `append`å‡½æ•°æ˜¯å¯ä»¥æ“ä½œå®ƒçš„, å› ä¸º`append`å‡½æ•°æ¥æ”¶çš„ä¸¤ä¸ªå‚æ•°éƒ½æ˜¯å®ç°`Semigroup`ç±»å‹ç±»çš„ç±»å‹.

æ‰€ä»¥æˆ‘ä»¬çœ‹åˆ°, `append mempty "a"`çš„æ—¶å€™, `append`åº”è¯¥æ¥æ”¶ä¸¤ä¸ª`String`ç±»å‹çš„å€¼, è™½ç„¶æˆ‘ä»¬ä¸çŸ¥é“`mempty`æ˜¯ä»€ä¹ˆç±»å‹çš„å€¼, ä½†æˆ‘ä»¬çŸ¥é“`"a"`æ˜¯`String`ç±»å‹çš„å€¼.

è€Œæˆ‘ä»¬åˆçŸ¥é“`append`æ˜¯è¦æ¥æ”¶ä¸¤ä¸ªç›¸åŒç±»å‹çš„å€¼ä½œä¸ºå‚æ•°çš„, æ‰€ä»¥, è¿™æ—¶å€™, `mempty`å°±æ˜¯`String`ç±»å‹çš„å€¼äº†.

ç›¸ä¼¼çš„, `append mempty (1 : 2 : 3 : Nil)`çš„æ—¶å€™, `mempty`å°±å˜æˆ`List Int`ç±»å‹çš„å€¼äº†.

å†çœ‹çœ‹`List`ç±»å‹å¯¹`Monoid`ç±»å‹ç±»çš„å®ç°:

```haskell
instance monoidList :: Monoid (List a) where
  mempty = Nil
```

å¾ˆç®€å•, `Nil`è€Œå·².

æ‰€ä»¥æ‰ä¼šçœ‹åˆ°, æŠŠ`mempty`å’Œ`(1 : 2 : 3 : Nil)`åˆåœ¨ä¸€èµ·ä¹‹å, ç­‰äº`(1 : 2 : 3 : Nil)`. è¿™ä¹Ÿç¬¦åˆæ³¨é‡Šé‡Œå†™çš„å®šå¾‹.

### Foldable

```haskell
-- | `Foldable` represents data structures which can be _folded_.
-- |
-- | - `foldr` folds a structure from the right
-- | - `foldl` folds a structure from the left
-- | - `foldMap` folds a structure by accumulating values in a `Monoid`

class Foldable f where
  foldr :: forall a b. (a -> b -> b) -> b -> f a -> b
  foldl :: forall a b. (b -> a -> b) -> b -> f a -> b
  foldMap :: forall a m. Monoid m => (a -> m) -> f a -> m
```

å®ç°è¿™ä¸ªç±»å‹ç±»çš„ç±»å‹æ˜¯"å¯ä»¥æŠ˜å "çš„.

è¦å®ç°è¿™ä¸ªç±»å‹ç±»å¿…é¡»å®ç°ä¸‰ä¸ªå‡½æ•°, `foldr`, `foldl`å’Œ`foldMap`.

å…¶ä¸­, `foldr`å’Œ`foldl`ä¹‹å‰æˆ‘ä»¬è¯´è¿‡, æ¥ç ”ç©¶ä¸€ä¸‹`foldMap`, å…ˆçœ‹ä¸€ä¸‹`foldMap`çš„ç­¾å:

å®ƒæœ‰ä¸¤ä¸ªæ³›å‹, `a`å’Œ`m`, å…¶ä¸­`m`å¿…é¡»å®ç°äº†`Monoid`ç±»å‹ç±», ä¹Ÿå°±æ˜¯è¯´`m`å¯ä»¥"åˆåœ¨ä¸€èµ·", åŒæ—¶`mempty`å¯ä»¥æ˜¯`m`ç±»å‹çš„å€¼.

å®ƒè¾“å…¥ä¸€ä¸ª`a`ç±»å‹åˆ°`m`ç±»å‹çš„å‡½æ•°, å’Œä¸€ä¸ªå¯ä»¥æŠ˜å ç±»å‹çš„å€¼, è¿™ä¸ªå¯æŠ˜å ç±»å‹çš„æ³›å‹ä¹Ÿæ˜¯`a`. æœ€å, è¿”å›ä¸€ä¸ª`m`ç±»å‹çš„å€¼.

ç»“åˆç­¾åå’Œæ³¨é‡Šçš„è¯´æ³•æ¥çŒœçŒœå®ƒçš„è¡Œä¸º:

æŠŠ`f a`æƒ³è±¡æˆ`List`, æ¯”å¦‚`List Int`, é‚£ä¹ˆ`a->m`çš„å‡½æ•°å°±æ˜¯`Int -> æŸä¸ªå®ç°Monoidçš„ç±»å‹m`. æˆ‘ä»¬å‡è£…`m`æ˜¯å­—ç¬¦ä¸²å§, é‚£ä¹ˆå‡½æ•°å†™`\a -> show a`.

è€Œæœ€åè¿”å›çš„`m`ç±»å‹çš„å€¼, å¯ä»¥æƒ³åˆ°`m`æ˜¯å¯ä»¥é€šè¿‡`append`åˆå¹¶çš„, æœ€åè¿”å›çš„åº”è¯¥æ˜¯`List`çš„æ¯ä¸ªå…ƒç´ è¢«å¤„å‡½æ•°å¤„ç†å, å¾—åˆ°çš„ç»“æœçš„åˆå¹¶.

è¯•è¯•:

```bash
> foldMap (\a -> show a) (1:2:3:4:5:Nil)
"12345"
```

é‚£å¦‚æœ`m`æ˜¯å…¶ä»–çš„å‘¢, æ¯”å¦‚æ˜¯ä¸ªæ•°ç»„:

```bash
> foldMap (\a -> [a+1]) (1:2:3:4:5:Nil)
[2,3,4,5,6]
```

çœ‹èµ·æ¥æˆ‘ä»¬çŒœå¯¹äº†.

ä¸è¿‡éœ€è¦è¯´æ˜çš„æ˜¯, è¿™æ ·çš„çŒœå¯¹äº†ä»…ä»…æ˜¯è¿æ°”å¥½è€Œå·².

è¿™ä¸ªç±»å‹ç±»æ²¡æœ‰å®šå¾‹çš„è§„å®š, æ³¨é‡Šä¹Ÿåªæ˜¯ç®€å•çš„è¯´"åœ¨`Monoid`ä¸­ç§¯ç´¯å€¼", å¹¶æ²¡æœ‰è¯¦ç»†è¯´æ˜ç»†èŠ‚.

å¦‚æœä½ ä¸çŸ¥é“ç±»å‹ç±»åˆ°åº•æƒ³è¡¨ç¤ºä»€ä¹ˆ, æˆ–è€…ä¸çŸ¥é“æ€ä¹ˆç”¨è‡ªå·±çš„ç±»å‹å®ç°ç±»å‹ç±», å°±çœ‹çœ‹ç±»å‹ç±»çš„æ³¨é‡Š, å†çœ‹çœ‹å„ç§ç±»å‹å¯¹å®ƒçš„å®ç°.

æ¥çœ‹çœ‹`List`çš„å®ç°:

```haskell
instance foldableList :: Foldable List where
  foldr f b = foldl (flip f) b <<< rev
    where
    rev = go Nil
      where
      go acc Nil = acc
      go acc (x : xs) = go (x : acc) xs
  foldl f = go
    where
    go b = case _ of
      Nil -> b
      a : as -> go (f b a) as
  foldMap f = foldl (\acc -> append acc <<< f) mempty
```

å¤æ‚çš„`foldr`å’Œ`foldl`å°±ä¸è¯´äº†, ç›¸ä¿¡ä½ ä¹Ÿå¯ä»¥çœ‹æ‡‚.

è¿™é‡Œæˆ‘ä»¬çœ‹çœ‹`foldMap`, è¿™é‡Œç”¨äº†`point-free`æ¨¡å¼, å®Œæ•´çš„å†™æ³•æ˜¯`foldMap f list = foldl (\acc -> append acc <<< f) mempty list`.

æ‰€ä»¥å¯¹äº`List`è€Œè¨€, `foldMap`çš„è¡Œä¸ºå°±æ˜¯ä»¥`mempty`ä¸ºåˆå§‹å€¼, å°†å…ƒç´ ä¸€ä¸ªä¸€ä¸ªé€šè¿‡å‡½æ•°å¤„ç†å, ä½¿ç”¨`append`æ‹¼åœ¨ä¸€èµ·.

### Functor

```haskell
-- | A `Functor` is a type constructor which supports a mapping operation
-- | `map`.
-- |
-- | `map` can be used to turn functions `a -> b` into functions
-- | `f a -> f b` whose argument and return types use the type constructor `f`
-- | to represent some computational context.
-- |
-- | Instances must satisfy the following laws:
-- |
-- | - Identity: `map identity = identity`
-- | - Composition: `map (f <<< g) = map f <<< map g`

class Functor f where
  map :: forall a b. (a -> b) -> f a -> f b
```

çœ‹çœ‹æ³¨é‡Šçš„è¯´æ³•: `map`å°†ä¸€ä¸ª`a -> b`çš„å‡½æ•°è½¬æ¢ä¸º`f a -> f b`çš„å‡½æ•°.

ä»€ä¹ˆæ„æ€? çœ‹çœ‹ä¾‹å­å°±çŸ¥é“äº†.

çœ‹çœ‹å¯¹`Maybe`ç±»å‹è€Œè¨€: æˆ‘ä»¬å‡è®¾`a`æ˜¯`Int`, `b`æ˜¯`String`, `f`è‡ªç„¶æ˜¯`Maybe`å•¦. ç­¾åæ˜¯`map :: (Int -> String) -> Maybe Int -> Maybe String`.

å†™ä¸€ä¸ªä¾‹å­:

```haskell
fun :: (Int -> String) -> Maybe Int -> Maybe String
fun f a = map f a 
```

```bash
> fun (\a -> show a) (Just 1) 
(Just "1")

> fun (\a -> show a) Nothing  
Nothing
```

æˆ‘ä»¬çš„å‡½æ•°`(\a -> show a)`, å®ƒåº”è¯¥æ˜¯`(Int -> String)`çš„, è€Œ`map (\a -> show a)`å, æˆ‘ä»¬å®é™…ä¸Šå¾—åˆ°äº†ä¸€ä¸ªæ–°çš„å‡½æ•°, ç­¾åæ˜¯`Maybe Int -> Maybe String`.

å°±æ˜¯è¯´è¿™ä¸ªæ–°çš„å‡½æ•°è¾“å…¥`Maybe Int`ç±»å‹çš„å€¼, è¿”å›`Maybe String`ç±»å‹çš„å€¼. äº‹å®ä¹Ÿæ­£æ˜¯å¦‚æ­¤, æˆ‘ä»¬è¾“å…¥äº†`(Just 1) `, å¾—åˆ°äº†`(Just "1")`.

è€Œå¦‚æœæ˜¯`Nothing`, æˆ‘ä»¬å°±ç›´æ¥è¿”å›`Nothing`, è¿™ä¹Ÿæ˜¯ç¬¦åˆç­¾åçš„, å› ä¸º`Nothing`æ—¢å¯ä»¥çœ‹ä½œ`Maybe Int`, ä¹Ÿå¯ä»¥çœ‹ä½œ`Maybe String`.

å†çœ‹çœ‹`List`ç±»å‹çš„æ•ˆæœ: æˆ‘ä»¬è¿˜æ˜¯å‡è®¾`a`æ˜¯`Int`, `b`æ˜¯`String`, `f`æ˜¯`List`å•¦. ç­¾åæ˜¯`map :: (Int -> String) -> List Int -> List String`.

å†™ä¸€ä¸ªä¾‹å­:

```bash
> map (\a -> show a) (1:2:3:Nil)
("1" : "2" : "3" : Nil)
```

çœ‹èµ·æ¥è¡Œä¸ºæ˜¯, å¯¹`List`ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ éƒ½è¿›è¡Œä¸€æ¬¡å‡½æ•°æ“ä½œ, ç¡®å®, è¿™æ ·å°±å¯ä»¥æŠŠ`List Int`è½¬æ¢ä¸º`List String`äº†.

æ‰€ä»¥, å¦‚æœä¸€ä¸ªç±»å‹`f`å®ç°äº†`Functor`ç±»å‹ç±», å°±æ„å‘³ç€:

æˆ‘ä»¬å¯ä»¥æŠŠä¸€ä¸ª`a -> b`çš„å‡½æ•°, é€šè¿‡`map`å¤„ç†å, å¾—åˆ°ä¸€ä¸ªæ–°å‡½æ•°, è¿™ä¸ªæ–°å‡½æ•°å¯ä»¥æ“ä½œè¿™ä¸ª`f`ç±»å‹.

å½“ç„¶, å…·ä½“å¦‚ä½•æ“ä½œ, ç”±ç±»å‹è‡ªå·±å®ç°, åªè¦æ»¡è¶³ç­¾åå’Œæ³¨é‡Šå†™çš„å®šå¾‹å³å¯.

è¿™æœ‰ä»€ä¹ˆç”¨å‘¢? ä¹‹åæˆ‘ä»¬ä¼šå†è®¨è®º.

## å¤šå‚æ•°ç±»å‹ç±»

ç±»å‹ç±»ä¹Ÿæ˜¯å¯ä»¥å¤šå‚æ•°çš„, æˆ‘ä»¬æ¥è‡ªå·±å†™ä¸€ä¸ª:

```haskell
class Split a b where
  uncons :: a -> Maybe { head :: b, tail :: a }
```

ç±»å‹ç±»`Split`æ˜¯è¡¨ç¤º"å¯ä»¥è¢«æ‹†åˆ†"çš„æ¦‚å¿µçš„. `a`æ˜¯å®¹å™¨ç±»å‹, `b`æ˜¯å…ƒç´ ç±»å‹. æœ‰ä¸€ä¸ªå‡½æ•°`uncons`å¯ä»¥æŠŠå®¹å™¨åˆ†æˆç¬¬ä¸€ä¸ªå…ƒç´ å’Œå‰©ä¸‹çš„å…ƒç´ .

æ¯”å¦‚, `a`å¯ä»¥æ˜¯`List Int`, é‚£ä¹ˆ`b`å°±æ˜¯`Int`. æœ‰ä¸€ä¸ªå‡½æ•°`uncons`å°±å¯ä»¥æŠŠ`(1:2:3:Nil)`è½¬æ¢æˆ`Just { head :: 1, tail :: (2:3:Nil) }`

åŒæ—¶, `a`ä¹Ÿå¯ä»¥æ˜¯`String`, é‚£ä¹ˆ`b`å°±æ˜¯Char. æœ‰ä¸€ä¸ªå‡½æ•°`uncons`å°±å¯ä»¥æŠŠ`"123"`è½¬æ¢æˆ`Just { head :: '1', tail :: "23" }`

å¹¸è¿çš„æ˜¯, è¿™ä¸¤ä¸ªç±»å‹çš„`uncons`å‡½æ•°å·²ç»æœ‰äººå¸®å¿™å†™å¥½äº†.

äºæ˜¯å®Œæ•´ä»£ç :

```haskell
module Main where

import Prelude

import Data.List (List)
import Data.List as List
import Data.Maybe (Maybe)
import Data.String.CodeUnits as String
import Effect (Effect)
import Effect.Console (log)

class Split a b where
  my_uncons :: a -> Maybe { head :: b, tail :: a }

instance unconsArray :: Split (List a) a where
  my_uncons list = List.uncons list

instance unconsString :: Split String Char where
  my_uncons s = String.uncons s

main :: Effect Unit
main = do
  log "ğŸ"
```

è¯•è¯•:

```bash
> my_uncons "123"
```

å±…ç„¶æŠ¥é”™äº†, ä¸ºä»€ä¹ˆå‘¢. 

å› ä¸ºç±»å‹åŒ¹é…ä¸å®Œæ•´, æŒ‰æ³›å‹åŒ¹é…, `class Split a b where`ä¸­çš„b, ä¹Ÿå°±æ˜¯`instance unconsString :: Split String Char where`ä¸­çš„`Char`.

ä½†æ˜¯æˆ‘çš„è¾“å…¥åªæœ‰ä¸€ä¸ª`String`ç±»å‹çš„å€¼, æ²¡æœ‰å‡ºç°`Char`, ç¼–è¯‘å™¨å°±ä¸çŸ¥é“è¦è°ƒç”¨è°äº†.

ä¸€ä¸ªæ–¹æ³•æ˜¯, å†™ä¸€ä¸ªå‡½æ•°, å†™æ¸…æ¥šç±»å‹, ç»™ç¼–è¯‘å™¨æä¾›æ›´å¤šä¿¡æ¯:

```haskell
fun :: String -> Maybe { head :: Char, tail :: String }
fun s = my_uncons s
```

å°±å¯ä»¥æ­£å¸¸ä½¿ç”¨äº†:

```bash
> fun "123"
(Just { head: '1', tail: "23" })
```

å¦ä¸€ä¸ªæ–¹æ³•æ˜¯:

```haskell
class Split a b | a -> b where
  my_uncons :: a -> Maybe { head :: b, tail :: a }
```

è¿™åé¢çš„`| a -> b`ç§°ä¸º`å‡½æ•°ä¾èµ–`, è¿™æ ·å†™å°±æ˜¯å‘Šè¯‰ç¼–è¯‘å™¨, å­˜åœ¨ä¸€ä¸ªå‡½æ•°, è¿™ä¸ªå‡½æ•°å¯ä»¥æŠŠ`a`ç±»å‹çš„å€¼`b`ç±»å‹çš„å€¼.

è¿™æ ·, ç¼–è¯‘å™¨çŸ¥é“äº†`a`ç±»å‹, å°±åŒæ—¶çŸ¥é“äº†`b`ç±»å‹.

è¯•è¯•:

```bash
> my_uncons "123"
(Just { head: '1', tail: "23" })
> my_uncons (1:2:3:Nil)
(Just { head: 1, tail: (2 : 3 : Nil) })
```

## ç©ºç±»å‹ç±»

çœ‹çœ‹æ¨¡å¼åŒ¹é…ä¸å…¨çš„åŒ¿åå‡½æ•°çš„ç±»å‹, æ¯”å¦‚å†™ä¸€ä¸ª, è¾“å…¥äºŒå…ƒæ•°ç»„, å°†å…ƒç´ ç›¸åŠ çš„å‡½æ•°:

```bash
> f = (\[a, b] -> a + b)
> :t f
forall (t3 :: Type). Partial => Semiring t3 => Array t3 -> t3
```

æ³¨æ„åˆ°, ç±»å‹çº¦æŸæ˜¯`Partial =>`. å¥‡æ€ªçš„æ˜¯, `Partial`åé¢å±…ç„¶æ²¡è·Ÿæ³›å‹å˜é‡.

è¿™æ˜¯ç§ç‰¹æ®Šçš„è§„å®š, ä½ æ— æ³•ç›´æ¥ä½¿ç”¨è¿™ä¸ªå‡½æ•°.

è€Œæˆ‘ä»¬ä¹‹å‰ç”¨è¿‡`unsafePartial`, å¯ä»¥è§£é™¤è¿™ä¸ªé™åˆ¶:

```bash
> unsafePartial f [1,2]
3
```

è¿™ç®—æ˜¯æŸç§ç‰¹æ®Šå†™æ³•.



