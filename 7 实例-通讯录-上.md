# 实例-通讯录-上

有了上面关于类型和函数的理解, 我们做一个通讯录, 作为练习, 也介绍更多的技巧.

## 需求分析

通讯录就是,记录人的地址.

我们可以给通讯录里加入一个新的记录, 也可以通过人名查找这个人的地址.

## 类型别名

我们先定义一个类型,表示通讯录中的一条记录,它有姓,名和地址.

```haskell
type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }
```

其中地址是另一个类型:包括街道,城市,国家.

```haskell
type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }
```

接下来,我们定义通讯录,它是"通讯录记录"组成的List:

```haskell
type AddressBook = List Entry
```

`type`关键词的逻辑很简单,就是做一个别名.

## 依赖库

注意上面出现的`List`,这是一个类型.

如果你把上面的代码写入文件,如果代码提示正常工作,你会看到List下面有红线,告诉你`Unknown type List`.

在之前的章节中, 我们自己定义了`List`, 但其实官方有实现过, 直接引入就可以了.

只要去它的库图书馆(https://pursuit.purescript.org)里搜索相关关键词,就可以找到对应的库,这里我们找到List:

https://pursuit.purescript.org/packages/purescript-lists/6.0.1

进而找到它的安装方法:

```bash
spago install lists
```

安装它.然后编译一下:

```bash
spago build
```

然后在文件中引入这个类型.

```haskell
import Data.List (List)
```

这里,`Data.List`是模块名,括号里的`List`是这个模块导出的一个类型,我们目前只引入这个类型.

最后,你的文件看起来像是这样:

```haskell
module Main where

import Prelude
import Effect (Effect)
import Effect.Console (log)
import Data.List (List)

type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }

type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }

type AddressBook = List Entry

main :: Effect Unit
main = do
  log "🍝"
```

## 函数

现在,我们编写一个函数来显示一个`Entry`类型的数据.

```haskell
showEntry :: Entry -> String
showEntry entry = entry.lastName <> ", " <> entry.firstName <> ": " <> (showAddress entry.address)
```

先看最后的`showAddress entry.address`,其中`entry.address`是从`entry`里访问`address`部分.

而前面的`showAddress`则是个函数,他们中间有一个空格.整个连起来表示:"以`entry.address`为参数调用函数`showAddress`".

(`showAddress`函数的定义稍后再写).

如果函数有多个参数, 就可以写`<函数名> <参数1> <参数2> ...`这样.

因为函数的柯里化, 这可以理解为, 给多参函数输入第一个参数后, 它返回了一个函数, 第二个参数是输入给它返回的这个新函数的...

特别的, 如果函数有两个参数, 可以用"中缀表达式"来更自然的表达.比如`+ 1 2`和`1 + 2`,显然是后者更加自然嘛.

这里的规定是, 我可以给函数对应一个符号. 然后这个符号就是中缀的, 而函数依然是前缀的. (如果你熟悉c++, 这就是运算符重载.)

比如这里的`<>`,对应的函数是`append`.它的作用是, 字符串连接.

这是定义中缀符号的写法:

```haskell
infixr 5 append as <>
```

`infixr`表示右结合, `5`是优先级, 数字越大优先级越高, 接下来就是函数名字和符号了.

你可以在交互模式里试试:

```bash
> append "a" "b"
"ab"

> "a" <>  "b"   
"ab"
```

这两者是等价的, 只是写法不同而已.

顺便一提, 你也可以用这种形式把函数中缀调用, 或把符号前缀调用:

```bash
> "a" `append` "b"
"ab"

> (<>) "a" "b"    
"ab"
```

总而言之, 这里

```bash
entry.lastName <> ", " <> entry.firstName <> ": " <> (showAddress entry.address)
```

所做的, 就是把`lastName`和`firstName`取出来, 字符串拼接, 再拼接上`showAddress entry.address`的结果.

那么showAddress的定义也差不多:

```haskell
showAddress :: Address -> String
showAddress addr = addr.street <> ", " <> addr.city <> ", " <> addr.state
```

输入一个`Address`类型的值, 把他的`street`,`city`和`state`取出来, 字符串拼接.

现在你的文件长这样:

```haskell
module Main where

import Prelude
import Effect (Effect)
import Effect.Console (log)
import Data.List (List)

type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }

type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }

type AddressBook = List Entry

showEntry :: Entry -> String
showEntry entry = entry.lastName <> ", " <> entry.firstName <> ": " <> showAddress entry.address

showAddress :: Address -> String
showAddress addr = addr.street <> ", " <> addr.city <> ", " <> addr.state

main :: Effect Unit
main = do
  log "🍝"

```

## 测试

现在,先编译一下:

```bash
spago build
```

然后进入交互模式, 引入`Main`模块:

```bash
> import Main
```

接下来, 我们构造数据分别测试一下这两个函数:

```bash
> address = { street: "123 Fake St.", city: "Faketown", state: "CA" }
> showAddress address
"123 Fake St., Faketown, CA"

> entry = { firstName: "John", lastName: "Smith", address: address }
> showEntry entry
"Smith, John: 123 Fake St., Faketown, CA"
```

ok, 完美运行.
