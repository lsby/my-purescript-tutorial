# 异步

上一章我们使用了fs的读文件封装, 当时为了简单, 我们使用的是同步的读文件形式.

就像你所知道的, 当然也会有异步的读文件封装, 甚至有不同形式的封装, 这里我们研究aff抽象: [purescript-node-fs-aff - Pursuit](https://pursuit.purescript.org/packages/purescript-node-fs-aff/7.0.0).

aff是比较常见的表示异步的抽象.

## 基础

看一个读文件的例子:

```haskell
module Main where

import Prelude

import Effect (Effect)
import Effect.Aff (launchAff_)
import Effect.Class (liftEffect)
import Effect.Console (log)
import Node.Encoding (Encoding(..))
import Node.FS.Aff (readTextFile)

main :: Effect Unit
main = launchAff_ do
  files <- readTextFile UTF8 "file"
  liftEffect $ log $ show files
```

重点是liftEffect, 因为readTextFile返回的是Aff String, 我们这个do的所有绑定都必须是Aff才行.

而liftEffect就是把Effect转成Aff的. 而launchAff_是把Aff转成Effect的.

当然他还有很多用法, 参见文档.

## 并行

再演示一个并行的情况.

考虑我们有一个数组, 数组里面的每一项都是某种计算, 如果他们互不干扰的话, 就可以并行计算.

这种特征被抽象为了类型类Parallel.

Aff也是可以支持并行计算的类型. 看这个例子:

```haskell
module Main where

import Prelude

import Control.Parallel (parSequence_)
import Data.Array (replicate)
import Data.Foldable (sequence_)
import Effect (Effect)
import Effect.Aff (Aff, Milliseconds(..), delay, launchAff_)

delayArray :: Array (Aff Unit)
delayArray = replicate 100 $ delay $ Milliseconds 10.0

seqDelay :: Effect Unit
seqDelay = launchAff_ $ sequence_ delayArray

parDelay :: Effect Unit
parDelay = launchAff_ $ parSequence_ delayArray

main :: Effect Unit
main = do seqDelay
-- main = do parDelay
```

先用delayArray构建一个100长度的数组, 其中每一项都是延时10毫秒.

`sequence_`来顺序执行, 而`parSequence_`可以并行执行.

当然也有其他的写法, 参加文档.