# 更多设定

借助之前的实例, 演示了基本编写方法, 本章将介绍更多设定.

## 条件判断和卫兵模式

演示`if语句`的用法, 写一个阶乘函数:

```haskell
factorial :: Int -> Int
factorial n =
  if n == 0 then
    1
  else
    n * factorial (n - 1)
```

作为一个简单写法, 可以写成`卫兵模式`(Guards):

```haskell
factorial :: Int -> Int
factorial n
  | n == 0 = 1
  | otherwise = n * factorial (n - 1)
```

它的形式是: `| 条件 = 值`, 会从上往下依次进行判断.最后`otherwise`是用来匹配其他情况, 就是`else`的部分.

卫兵模式就是`if-elif-else`的语法糖.

另外,这些用模式匹配也可以实现:

```haskell
factorial :: Int -> Int
factorial 0 = 1
factorial n = n * factorial (n - 1)
```

## 匿名函数

可以这样写一个匿名函数:

```bash
> (\n -> n + 1) 1
2
```

匿名函数以`\`开头, 然后写参数, 然后箭头后是函数实现. 不过这样就没法写函数签名了.

多参数的话:

```bash
> (\a b -> a + b) 1 2   
3
```

## 记录访问器

如果我们要写一个函数, 返回给定的记录的某一项, 大概是这样:

```haskell
type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }

type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }

getFirstName :: Entry -> String
getFirstName entry = entry.firstName
```

使用:

```haskell
> addressData = { street: "123 Fake St.", city: "Faketown", state: "CA" }
> entryData = { firstName: "John", lastName: "Smith", address: addressData }
> getFirstName entryData
"John"
```

有个简单的语法糖可以避免我们编写这样的函数:

```bash
> address = { street: "123 Fake St.", city: "Faketown", state: "CA" }
> entry = { firstName: "John", lastName: "Smith", address: address }
> _.lastName entry
"Smith"
> _.address.city entry
"Faketown"
```

## 函数泛型

我们想来计算`List`的长度.

```haskell
f :: List Int -> Int
f Nil = 0
f (Cons x xs) = 1 + f xs
```

测试:

```bash
> f (Cons 1 (Cons 2 (Cons 3 Nil)))
3
```

但这只能适用于`List Int`类型的`List`. 毕竟签名上写的都是`List Int`.

像是这样就会报错了:

```bash
> f (Cons "1" (Cons "2" (Cons "3" Nil)))
Error found:
  Could not match type
    String
  with type
    Int
```

这里, 我们可以使用泛型:

```haskell
f :: forall a. List a -> Int
f Nil = 0
f (Cons x xs) = 1 + f xs
```

前面的`forall`是泛型的标志, 后面跟着泛型的符号, 接下来的签名里就可以用这个符号作为类型了.

这样, 当我们:

```bash
> f (Cons "1" (Cons "2" (Cons "3" Nil)))
```

系统就会发现泛型`a`在本次调用中是`String`类型, 于是函数的签名变成了`List String -> Int`.

当然, 如果我们:

```bash
> f (Cons 1 (Cons 2 (Cons 3 Nil)))
```

系统就会发现泛型`a`在本次调用中是`Int`类型, 于是函数的签名变成了`List Int-> Int`.

泛型还可以用在更多地方, 例如:

```haskell
f :: forall a. List a -> a
```

这个签名意味着, 如果输入一个`List Int`, 就会返回`Int`, 如果输入的是`List String`, 就会返回`String`. 这可能是取数组第一个或最后一个元素的函数.

之后我们会见到更多例子.

## 模式匹配

关于模式匹配还有很多细节.

### 忽略参数

你不可以用两个相同的形参去匹配不同位置的值, 即使用不到它, 比如, 这样会报错:

```haskell
fun :: List Int -> Int
fun [a, b, b] = a
fun arr = 0
```

但有一个特殊的写法, 下划线, 表示不使用这个参数, 这样重复就没有关系了:

```haskell
fun :: List Int -> Int
fun [a, _, _] = a
fun arr = 0
```

### 完全覆盖

模式匹配可以使用通配符, 就是下划线, 表示任意的匹配.

比如, 来写一个函数计算二元数组的乘积:

```haskell
fun :: Array Int -> Int
fun ([a, b]) = a * b
```

但这样会报错, 因为, 如果你输入的不是二元数组怎么办? 比如空数组也能满足函数签名, 但我们的函数无法处理它.

于是可以写成这样:

```haskell
fun :: Array Int -> Int
fun ([a, b]) = a * b
fun arr = 0
```

这个`arr`就匹配了其他情况的数组.

这样就覆盖了所有可能.

### 局部模式

匿名函数自然也可以模式匹配, 比如把上面算二元数组乘法的函数写成匿名函数:

```haskell
> (\[a, b] -> a * b) [1, 2]
```

可惜这样会报错, 因为模式匹配不全, 但匿名函数里我们没法做更多匹配啊?

如果你知道你在做什么, 有一个办法, 使用`Partial.Unsafe`模块提供的`unsafePartial`函数来解除约束.

```bash
import Partial.Unsafe
> unsafePartial (\[a, b] -> a * b) [1, 2]
2
```

### 记录模式

我们可以这样来匹配记录的值, 匹配成对应的参数:

```haskell
showPerson :: { first :: String, last :: String } -> String
showPerson { first: x, last: y } = y <> ", " <> x
```

测试:

```bash
> showPerson { first: "aaa", last: "bbb" }
"bbb, aaa"
```

但糟糕的是:

```bash
> showPerson { first: "aaa", last: "bbb", sex:"ccc" }
```

这样就会出错了, 因为模式不匹配.

### 记录行多态

但幸运的是, 有一种写法可以更加宽松的匹配, 称为行多态.

```haskell
showPerson :: forall r. { first :: String, last :: String | r } -> String
showPerson { first: x, last: y } = y <> ", " <> x
```

函数签名的地方变了, 多了一个泛型`r`, 同时记录模式里增加了`| r`.

这样就可以匹配更多的记录了, 只要这个记录带有`first`和`last`就可以了:

```bash
> showPerson { first: "aaa", last: "bbb", sex:"ccc" }
"bbb, aaa"
```

### 记录双关语

对于这样的匹配:

```haskell
showPerson :: { first :: String, last :: String } -> String
showPerson { first: first, last: last } = last <> ", " <> first
```

如果我们需要的形参和输入记录的键一样的话, 可以省略:

```haskell
showPerson :: { first :: String, last :: String } -> String
showPerson { first, last } = last <> ", " <> first
```

除了用在模式匹配上, 构造记录的时候也能用:

```haskell
unknownPerson :: { first :: String, last :: String }
unknownPerson = { first, last }
  where
    first = "Jane"
    last  = "Doe"
```

效果:

```bash
> unknownPerson
{ first: "Jane", last: "Doe" }
```

### 嵌套模式

模式匹配允许任意深度的嵌套:

```haskell
type Address = { street :: String, city :: String }
type Person = { name :: String, address :: Address }
livesInLA :: Person -> Boolean
livesInLA { address: { city: "Los Angeles" } } = true
livesInLA _ = false
```

效果:

```bash
> livesInLA { name: "aaa", address: { street: "bbb", city: "Los Angeles" }}      
true
> livesInLA { name: "aaa", address: { street: "bbb", city: "ccc" }}        
false
```

### 命名模式

有时候我们可能同时需要匹配前的整体和匹配后的部分.

输入一个二元数组, 对它排序:

```haskell
sortPair :: Array Int -> Array Int
sortPair arr@[x, y]
  | x <= y = arr
  | otherwise = [y, x]
sortPair _ = []
```

这样写的话, `arr`就等价于`[x, y]`, 写起来更简洁一点.

## 数组操作

### 映射

输入一个函数和一个数组, 将数组的每个元素分别应用于函数, 得到一个新的数组:

```bash
> map (\n -> n + 1) [1, 2, 3, 4, 5]
[2, 3, 4, 5, 6]

# 它的符号重载
> (\n -> n + 1) <$> [1, 2, 3, 4, 5]
[2,3,4,5,6]
```

### 数组生成器

```bash
> 1 .. 5
[1, 2, 3, 4, 5]
```

### 过滤

```bash
> filter (\n -> n `mod` 2 == 0) (1 .. 10)
[2,4,6,8,10]
```

### 展平

```bash
> concat [[1, 2, 3], [4, 5], [6]]
[1, 2, 3, 4, 5, 6]
```

### 映射后展平

```bash
> concatMap (\n -> [n, n * n]) (1 .. 5)
[1,1,2,4,3,9,4,16,5,25]
```

### 数组的 do 表示法

```haskell
module Main where

import Prelude

import Effect (Effect)
import Effect.Console (log)

f :: Array Int
f = do
  i <- [1,2,3]
  j <- [2,3,4]
  [i, j]

main :: Effect Unit
main = do
  log $ show $ f
-- 得到 [1,2,1,3,1,4,2,2,2,3,2,4,3,2,3,3,3,4]
```

好的, 这个有点复杂, 一点一点来.

首先, `do`是一个语法糖, 这个代码等价于:

```haskell
f :: Array Int
f =
  [1,2,3] >>= \i -> 
    [2,3,4] >>= \j -> 
      [i, j]
```

其中. `>>=`是`bind`的中缀符号.所以也等价于:

```haskell
f :: Array Int
f = bind [1,2,3] (\i -> bind [2,3,4] (\j -> [i, j]))
```

对于数组而言`bind`函数就是`concatMap`(其他类型会在后面的章节讨论),不过顺序调换了一下.所以等价于:

```haskell
f :: Array Int
f = concatMap (\i -> concatMap (\j -> [i, j]) [2,3,4]) [1,2,3]
```

那么首先先看里面的`concatMap (\j -> [i, j]) [2,3,4]`, 他映射后会得到`[[i,2],[i,3],[i,4]]`, 其中i是从闭包取的, 然后拉平就是`[i,2,i,3,i,4]`.

而整体的表达式, 映射后会得到, `[(i=1的情况),(i=2的情况),(i=3的情况)]`.

就是:`[[1,2,1,3,1,4],[2,2,2,3,2,4],[3,2,3,3,3,4]]`, 然后拉平, 得到`[1,2,1,3,1,4,2,2,2,3,2,4,3,2,3,3,3,4]`.

#### 应用

这个可以解决很多常见的枚举问题, 举个例子, 分解因数: 给定一个整数`n`, 将它写成`a * b`的形式.

简单的, 我们只要尝试所有的可能就行了, 但在此之前要先列出所有的可能, `a`的取值范围是`1..n`, `b`的也是.

```haskell
module Main where

import Prelude

import Data.Array ((..))
import Effect (Effect)
import Effect.Console (log)

f :: Int -> Array (Array Int)
f n = do 
  a <- 1 .. n
  b <- 1 .. n
  [[a,b]]
  
main :: Effect Unit
main = do
  log $ show $ f 3
-- 得到 [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
```

这里, `<-`可以理解为"选择","可能是":`a`可能是`1`到`n`中的任何一个, (`b`也一样), 返回所有的`[a, b]`序列.

再套个过滤就完成了:

```haskell
f :: Int -> Array (Array Int)
f n = filter (unsafePartial \[a, b] -> a * b == n) do
  a <- 1 .. n
  b <- 1 .. n
  [[a,b]]
```

#### 守卫模式

另一种写法是`do 中的守卫模式`:

```haskell
f :: Int -> Array (Array Int)
f n = do
  a <- 1 .. n
  b <- 1 .. n
  guard $ a * b == n
  [[a,b]]
```

`guard`函数来自`Control.MonadZero`模块, 可以和过滤有相同的效果, 但看起来更简洁.

## 折叠

有两个函数, `foldl`和`foldr`, 他们在`Data.Foldable`里.

```bash
> import Data.Foldable

> :type foldl
forall a b f. Foldable f => (b -> a -> b) -> b -> f a -> b

> :type foldr
forall a b f. Foldable f => (a -> b -> b) -> b -> f a -> b
```

如果你知道`js`里数组的`reduce`做了什么的话, 你就理解了`foldl`在做什么.

如果你玩过游戏的话, 应该见过"装备合成"的界面, 有两个槽位, 一个放装备, 一个放宝石, 点一下合成, 宝石消失, 装备升级, 然后, 装备还在那里, 你再放下一个宝石.

这是差不多的, 我们有一个初始值, 和数组中的每一项, 我们取出数组的一项, 让它和初始值合成, 然后再放数组的下一项, 直到数组元素用完.

他们的不同是, `foldl`是从左往右拿数组项, `foldr`是从右往左拿数组项. 另外注意函数的参数是相反的.

```bash
> foldl (+) 0 (1 .. 5)
15
> foldr (+) 0 (1 .. 5)
15
> foldl (\acc n -> acc <> show n) "" [1,2,3,4,5]
"12345"
> foldr (\n acc -> acc <> show n) "" [1,2,3,4,5]
"54321"
```

你或许意识到了, 折叠是某种意义上的循环, 但它比循环更严格.

虽然有尾递归优化, 但我们还是建议你尽量考虑使用折叠实现你的功能, 因为通常它会更简单.

## case 模式

拿之前计算`List`长度的函数来说:

```haskell
f :: forall a. List a -> Int
f Nil = 0
f (Cons x xs) = 1 + f xs
```

其实他等价于:

```haskell
f :: forall a. List a -> Int
f a = case a of
  Nil -> 0
  (Cons x xs) -> 1 + f xs
```

这叫`case 模式`, 模式匹配只是它的语法糖.

它的形式是, `case`后面跟一个表达式, 接下来, `of`后面去写表达式的各种模式, 箭头后面写上对应的返回值.

它比模式匹配更好的一点是, 它可以匹配表达式, 而模式匹配只能匹配参数. 例如:

```haskell
f :: Array Number -> Boolean
f a = case sum a % 2.0 of
  0.0 -> true
  1.0 -> false
  _ -> false
```

输入一个数组, 计算它的和, 然后除以`2`算余数, 如果是`0`, 返回`true`, 如果是`1`返回`false`.

## newtype

之前我们说过`data`, 用来定义数据类型, 而`newtype`和它很像, 但区别是, `newtype`只能有一个构造子, 并且这个构造子只能有一个参数.

```bash
> newtype AA = AA Int
> :t (AA 1)
AA
```

这样的好处是, 既能把基础类型包装为构造子的形式, 又不会有性能损耗. (它比`data`包装的性能更好).

## show

之前, 我们为了打印, 写了各种`show`函数, 把特定的数据类型转换为字符串.

实际上, 大部分的数据类型都已经帮我们实现好了转字符串的功能, 类似于其他语言里的`toString`一样.

使用的函数是`show`:

```haskell
> show (Cons 1 (Cons 2 (Cons 3 Nil)))
"(1 : 2 : 3 : Nil)"
> show [1,2,3]                       
"[1,2,3]"
> show {"a":1,"b":2}
"{ a: 1, b: 2 }"
> show {"a":[1,2,3],"b":(Cons 1 (Cons 2 (Cons 3 Nil)))}
"{ a: [1,2,3], b: (1 : 2 : 3 : Nil) }"
```

它会自动处理各种结构, 当然这并不是真的自动, 实际上每个类型里都要实现`show`的类型类才能有效, 类型类的问题我们之后会讨论.

总之, 现在我们可以不用写转字符串的函数了, 在大部分情况下, `show`都能很好的工作.