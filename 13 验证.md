# 验证

本章讲解一个常见的应用,数据验证,及其实现.

## Maybe

https://pursuit.purescript.org/packages/purescript-maybe/5.0.0/docs/Data.Maybe

### 单参数

Maybe适用于"数据可能不存在"的情况,比如,我们要从数据库中读一个数据回来,然后对它进行处理.

但数据库读取可能失败,所以读数据库的函数应该返回Maybe String,而不是String.

假如我们读回来了一个名字,现在要对它问好.

我们先写出问好函数:

```haskell
fun1 :: String -> String
fun1 a = "hello, " <> a
```

但问题是这个函数输入的是String,而不是Maybe String.但没关系,因为Maybe实现了函子类型类,所以我们可以用map提示fun,让它能用在Maybe上.

```haskell
> map fun1 Nothing  
Nothing

> map fun1 (Just "abc")
(Just "hello, abc")
```

### 多参数

如果是多参数函数呢?如果我们有两个Maybe数据,嗯..比如把他连起来成一个字符串.

首先先是连起来成字符串的函数

```haskell
fun2 :: String -> String -> String
fun2 a b = a <> b
```

因为Maybe也实现了应用函子, 所以就像之前说的,提升多参数函数,用lift:

```haskell
> lift2 fun2 (Just "a") (Just "b")
(Just "ab")

> lift2 fun2 (Just "a") (Nothing) 
Nothing

> lift2 fun2 (Nothing) (Just "b") 
Nothing
```

当然也可以用`<$>`和`<*>`的形式:

```haskell
> fun2 <$> (Just "a") <*> (Just "b")
(Just "ab")
```

## Either

https://pursuit.purescript.org/packages/purescript-either/5.0.0

看起来很好,如果输入的任何一个是Nothing,得到的就会是Nothing.

但如果我想要程序精确的提示哪个参数不存在,怎么办?

有一个数据类型是Either,它有两个构造子,Left和Right.

```haskell
data Either a b = Left a | Right b
```

这个类型表示"两种类型的值间做选择"的模式.

它的map实现很有意思, 如果值是用Left构造的, 将不会计算, 永远保持不变, 而如果值是Right构造的, 就会计算.

```haskell
f <$> Right x == Right (f x)
f <$> Left y == Left y
```

它也实现了应用函子,也是一样,左值不变,右值计算:

```haskell
Right f <*> Right x == Right (f x)
Left f <*> Right x == Left f
Right f <*> Left y == Left y
```

所以很容易用它做错误提示,只需要检查一下输入的Maybe是不是Nothing,如果是,就建一个Left,反正它怎么算都不会变,最后一定得到的还是它.

写一个转换函数:

```haskell
genErr :: forall a. Maybe a -> String -> Either String a
genErr (Nothing) tip = Left tip
genErr (Just a) _ = Right a
```

输入一个Maybe值,和一个提示字符串,如果Maybe值是Nothing,用左值包装tip,否则用右值包装Maybe的值.

```haskell
> map fun1 (genErr Nothing "err tip")     
(Left "err tip")

> map fun1 (genErr (Just "abc") "err tip")
(Right "hello, abc")
```

```haskell
> lift2 fun2 (genErr (Just "abc") "err tip1") (genErr (Just "def") "err tip2")
(Right "abcdef")

> lift2 fun2 (genErr (Just "abc") "err tip1") (genErr Nothing "err tip2")     
(Left "err tip2")

> lift2 fun2 (genErr Nothing "err tip1") (genErr (Just "def") "err tip2")     
(Left "err tip1")

> lift2 fun2 (genErr Nothing "err tip1") (genErr Nothing "err tip2")     
(Left "err tip1")
```

需要注意的是如果两个值都是Nothing, 只会返回第一个报错, 毕竟出现第一个报错后, 他就不会再变了.

## V

如何一次获得全部错误呢?

想想也很简单,只要改改Left的行为,把他从"什么都不做"改成"累积结果"就可以了,不过有另一个数据已经帮我们实现了.

https://pursuit.purescript.org/packages/purescript-validation/5.0.0/docs/Data.Validation.Semigroup#t:V

它有很多用法,看看说明中的各种函数就知道,不过我们用最简单的,看看它的构造子:

```haskell
newtype V err result = V (Either err result)
```

之前讲过newtype基本等于高性能版的data.也就是说V这个类型有一个同名的构造子, 这个构造子需要传入一个`Either err result`的值.

而`err`和`result`是泛型类型.

改造一下刚才的转换函数:

```haskell
genErr :: forall a. Maybe a -> String -> V String a
genErr (Nothing) tip = V (Left tip)
genErr (Just a) _ = V (Right a)
```

试试:

```haskell
> lift2 fun2 (genErr Nothing "err tip1") (genErr Nothing "err tip2")     
invalid ("err tip1err tip2")
```

看起来不是很好, 两个错误混在一起了, 事实上, 只要返回任意一个符合半群的类型都行,我们用数组试试:

```haskell
genErr :: forall a. Maybe a -> String -> V (Array String) a
genErr (Nothing) tip = V (Left [tip])
genErr (Just a) _ = V (Right a)
```

```haskell
> lift2 fun2 (genErr Nothing "err tip1") (genErr Nothing "err tip2")     
invalid (["err tip1","err tip2"])
```

非常完美!

## 正则验证

现在我们仅仅是验证数据是不是Nothing,如果我们要验证它的形式呢?

这里有一个正则类型

https://pursuit.purescript.org/packages/purescript-strings/5.0.0/docs/Data.String.Regex#t:Regex

看看如何使用,首先可以找到一个叫`test`的方法.

```haskell
-- | Returns `true` if the `Regex` matches the string. In contrast to
-- | `RegExp.prototype.test()` in JavaScript, `test` does not affect
-- | the `lastIndex` property of the Regex.
foreign import test :: Regex -> String -> Boolean
```

就是我们要找的测试函数了,那么`Regex`类型的数据哪来呢?

找到了这个:

```haskell
-- | Constructs a `Regex` from a pattern string and flags. Fails with
-- | `Left error` if the pattern contains a syntax error.
regex :: String -> RegexFlags -> Either String Regex
```

那么还缺一个`RegexFlags`的构造方法,找到这个:

```haskell
-- | Parses the string representation of `RegexFlags`.
parseFlags :: String -> RegexFlags
```

齐了,先来试试:

```haskell
> map (\a->test a "aaaa") (regex "aaa" (parseFlags "g"))
(Right true)

> map (\a->test a "123") (regex "aaa" (parseFlags "g")) 
(Right false)
```

那么现在试试用在fun2上, 比如我需要fun2的第一个参数是数字, 第二个参数是字母. 对应的正则是"^[0-9]\*$"和"^[a-zA-Z]\*$".

用多种花样写了差不多的东西...

```haskell
isNumber :: Maybe String -> String -> V (Array String) String
isNumber (Nothing) tip = V (Left [tip])
isNumber (Just a) tip = case regObj of
    (Left s) -> V (Left [s])
    (Right reg) -> case test reg a of
      true -> V (Right a)
      false -> V (Left [tip])
    where
      regObj :: Either String Regex
      regObj = regex "^[0-9]*$" (parseFlags "g")

isLetter :: Maybe String -> String -> V (Array String) String
isLetter (Nothing) tip = V (Left [tip])
isLetter (Just a) tip = case lift2 test regObj (Right a) of
  (Left e) -> V (Left [tip])
  (Right true) -> V (Right a)
  (Right false) -> V (Left [tip])
  where
    regObj :: Either String Regex
    regObj = regex "^[a-zA-Z]*$" (parseFlags "g")
```

试试:

```haskell
> isNumber (Nothing) "err"
invalid (["err"])

> isNumber (Just "aaa") "err"
invalid (["err"])

> isNumber (Just "123") "err"
pure ("123")

> isLetter (Nothing) "err"   
invalid (["err"])

> isLetter (Just "aaa") "err"
pure ("aaa")

> isLetter (Just "123") "err"
invalid (["err"])
```

```haskell
> lift2 fun2 (isNumber (Just "1") "err1") (isLetter (Just "a") "err2")
pure ("1a")

> lift2 fun2 (isNumber (Just "1") "err1") (isLetter (Just "1") "err2")
invalid (["err2"])

> lift2 fun2 (isNumber (Just "a") "err1") (isLetter (Just "a") "err2")
invalid (["err1"])

> lift2 fun2 (isNumber (Just "a") "err1") (isLetter (Just "1") "err2")
invalid (["err1","err2"])
```

## 遍历

Traversable是一个类型类.

https://pursuit.purescript.org/packages/purescript-foldable-traversable/5.0.1/docs/Data.Traversable#t:Traversable

```haskell
class (Functor t, Foldable t) <= Traversable t where
  traverse :: forall a b m. Applicative m => (a -> m b) -> t a -> m (t b)
  sequence :: forall a m. Applicative m => t (m a) -> m (t a)
```

### sequence

想象这样一个场景:你有一个List (IO a),这可以理解为,一个list的每一项都是一个需要IO操作才可以获得的数据,这个数据是a类型的.

如果把这些IO操作都计算了,我们可以得到List a.

但实际上,我可能需要的就是List a的数据,但IO操作不执行也不行呀?但至少,我们可以把IO合成一个,然后先计算.

也就是将数据转换为IO (List a).

sequence就是做这件事的.

IO能合成一个的条件是它必须实现Applicative类型类. 我们之前说过, Applicative就是合并多个同上下文数据的接口.

事实上不只是IO,任何实现Applicative类型类的类型都可以做如此的转换.

而Traversable就是对这种能力的抽象.

### traverse

你可以看到文档上的备注:

```haskell
traverse f xs = sequence (f <$> xs)
```

也就是说, traverse和sequence的区别, 仅仅是多输入一个函数, 然后这个函数会先应用到输入数据上.

例如:

```haskell
traverse fromNumber [1.0, 2.0, 3.0] == Just [1,2,3]
```

其中`fromNumber`是将小数转成整数的函数.

这个写法的行为是, 先用`fromNumber`应用到数组的每个元素上, 得到了`[Just 1,Just 2,Just 3]`, 然后再执行`sequence`.

### 多个验证

这适用于一种场景: 一个List里有多个数据要以相同规则验证.

例如, 考虑一个"地址"的结构, 一个结构包含姓名,住址,电话号码等. 但电话号码是一个List, 因为可能有人有多个电话号码.

对于每一个电话号码, 都应该是符合一定要求的数字, 我们可以用正则验证函数来验证, 返回一个`V (Array String) String`类型的数据.

但对于一个数组, 我们无法使用检查函数, 只能将检查函数提升, 得到的是`List (V (Array String) String)`类型的数据.

但我们并不想得到这个, 我们想要是一个V返回的错误或原始的List.

而sequence可以帮助我们把`List (V (Array String) String)`转换为`V (Array String) (List String)`. 这就是我们所需要的.

来试试, 我们就用刚才写的`isNumber`函数.

```haskell
> sequence $ lift2 isNumber [Just "111", Just "222", Just "333"] (pure "err")  
pure (["111","222","333"])

> sequence $ lift2 isNumber [Just "111", Just "222", Nothing] (pure "err")     
invalid (["err"])
```
